<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<database name="clouddb" schema="public" type="PostgreSQL - 12.8">
   <sequences>
      <sequence increment="1" name="aggregate_impacts_id_seq" startValue="1"/>
      <sequence increment="1" name="aggregate_totals_id_seq" startValue="1"/>
      <sequence increment="1" name="allowed_configuration_values_id_seq" startValue="1"/>
      <sequence increment="1" name="asset_types_id_seq" startValue="1"/>
      <sequence increment="1" name="asset_value_types_id_seq" startValue="1"/>
      <sequence increment="1" name="asset_values_id_seq" startValue="1"/>
      <sequence increment="1" name="assets_id_seq" startValue="1"/>
      <sequence increment="1" name="assets_impact_functions_id_seq" startValue="1"/>
      <sequence increment="1" name="configurations_id_seq" startValue="1"/>
      <sequence increment="1" name="customers_id_seq" startValue="1"/>
      <sequence increment="1" name="decadal_states_id_seq" startValue="1"/>
      <sequence increment="1" name="derived_vars_id_seq" startValue="1"/>
      <sequence increment="1" name="folders_id_seq" startValue="1"/>
      <sequence increment="1" name="grid_squares_id_seq" startValue="1"/>
      <sequence increment="1" name="grids_id_seq" startValue="1"/>
      <sequence increment="1" name="group_value_types_id_seq" startValue="1"/>
      <sequence increment="1" name="groups_id_seq" startValue="1"/>
      <sequence increment="1" name="hazard_metrics_id_seq" startValue="1"/>
      <sequence increment="1" name="impact_functions_id_seq" startValue="1"/>
      <sequence increment="1" name="impact_pathways_id_seq" startValue="1"/>
      <sequence increment="1" name="investments_id_seq" startValue="1"/>
      <sequence increment="1" name="loc_grid_squares_id_seq" startValue="1"/>
      <sequence increment="1" name="loc_regions_id_seq" startValue="1"/>
      <sequence increment="1" name="locations_id_seq" startValue="1"/>
      <sequence increment="1" name="ref_id_id_seq" startValue="1"/>
      <sequence increment="1" name="region_areas_id_seq" startValue="1"/>
      <sequence increment="1" name="regions_id_seq" startValue="1"/>
      <sequence increment="1" name="rf_categories_id_seq" startValue="1"/>
      <sequence increment="1" name="rf_category_hierarchies_id_seq" startValue="1"/>
      <sequence increment="1" name="rf_category_risk_factors_id_seq" startValue="1"/>
      <sequence increment="1" name="risks_id_seq" startValue="1"/>
      <sequence increment="1" name="roles_id_seq" startValue="1"/>
      <sequence increment="1" name="roles_scopes_id_seq" startValue="1"/>
      <sequence increment="1" name="scenarios_id_seq" startValue="1"/>
      <sequence increment="1" name="scopes_id_seq" startValue="1"/>
      <sequence increment="1" name="tags_id_seq" startValue="1"/>
      <sequence increment="1" name="tcs_metadata_id_seq" startValue="1"/>
      <sequence increment="1" name="updates_id_seq" startValue="1"/>
      <sequence increment="1" name="users_configurations_id_seq" startValue="1"/>
      <sequence increment="1" name="users_id_seq" startValue="1"/>
      <sequence increment="1" name="users_roles_customers_id_seq" startValue="1"/>
   </sequences>
   <tables>
      <table name="aggregate_impacts" numRows="7901926" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('aggregate_impacts_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="19" type="bigserial" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="aggregate_level" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="entity_id" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="tags_hash_md5" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="risk_factor_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="aggregate_impacts_risk_factor_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="risk_factors"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="scenario_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="aggregate_impacts_scenario_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="scenarios"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="yr" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="7" name="impact_abs" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="8" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="9" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="batch_id" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="aggregate_impacts_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="aggregate_impacts_c01" unique="true">
            <column ascending="true" name="aggregate_level"/>
            <column ascending="true" name="entity_id"/>
            <column ascending="true" name="tags_hash_md5"/>
            <column ascending="true" name="risk_factor_id"/>
            <column ascending="true" name="scenario_id"/>
            <column ascending="true" name="yr"/>
         </index>
         <index name="aggregate_impacts_i02" unique="false">
            <column ascending="true" name="aggregate_level"/>
         </index>
         <index name="aggregate_impacts_i03" unique="false">
            <column ascending="true" name="entity_id"/>
         </index>
         <index name="aggregate_impacts_i04" unique="false">
            <column ascending="true" name="tags_hash_md5"/>
         </index>
         <index name="aggregate_impacts_i05" unique="false">
            <column ascending="true" name="risk_factor_id"/>
         </index>
         <index name="aggregate_impacts_i06" unique="false">
            <column ascending="true" name="scenario_id"/>
         </index>
         <index name="aggregate_impacts_i07" unique="false">
            <column ascending="true" name="yr"/>
         </index>
      </table>
      <table name="aggregate_risks" numRows="133008" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="customer_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="aggregate_risks_customer_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="customers"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="entity_type" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="entity_id" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="scenario_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="aggregate_risks_scenario_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="scenarios"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="decade" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="hazard_metric_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="aggregate_risks_hazard_metric_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="hazard_metrics"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="risk_factor_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="aggregate_risks_risk_factor_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="risk_factors"/>
         </column>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="7" name="risk_factor_name" nullable="true" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="8" name="risk_factor_category_name" nullable="true" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="tcfd_id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="10" name="entity_value" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="11" name="entity_impact" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="12" name="entity_portion_at_risk" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <primaryKey column="customer_id" sequenceNumberInPK="1"/>
         <primaryKey column="entity_type" sequenceNumberInPK="2"/>
         <primaryKey column="entity_id" sequenceNumberInPK="3"/>
         <primaryKey column="scenario_id" sequenceNumberInPK="4"/>
         <primaryKey column="decade" sequenceNumberInPK="5"/>
         <primaryKey column="hazard_metric_id" sequenceNumberInPK="6"/>
         <primaryKey column="risk_factor_id" sequenceNumberInPK="7"/>
         <index name="aggregate_risks_pkey" unique="true">
            <column ascending="true" name="customer_id"/>
            <column ascending="true" name="entity_type"/>
            <column ascending="true" name="entity_id"/>
            <column ascending="true" name="scenario_id"/>
            <column ascending="true" name="decade"/>
            <column ascending="true" name="hazard_metric_id"/>
            <column ascending="true" name="risk_factor_id"/>
         </index>
      </table>
      <table name="aggregate_totals" numRows="41630" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('aggregate_totals_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="19" type="bigserial" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="aggregate_level" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="entity_id" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="3" name="parent_entity_id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="tags_hash_md5" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="5" name="qty_children" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="6" name="qty_children_done" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="0" digits="17" id="7" name="value_abs" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="qty_assets" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="9" name="qty_assets_complete_hazards" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="10" name="qty_assets_complete_risks" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="11" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="aggregate_totals_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="aggregate_totals_c01" unique="true">
            <column ascending="true" name="aggregate_level"/>
            <column ascending="true" name="entity_id"/>
            <column ascending="true" name="tags_hash_md5"/>
         </index>
         <index name="aggregate_totals_i02" unique="false">
            <column ascending="true" name="aggregate_level"/>
         </index>
         <index name="aggregate_totals_i03" unique="false">
            <column ascending="true" name="entity_id"/>
         </index>
         <index name="aggregate_totals_i04" unique="false">
            <column ascending="true" name="tags_hash_md5"/>
         </index>
      </table>
      <table name="allowed_configuration_values" numRows="1" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('allowed_configuration_values_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="allowed_configuration_value_id" foreignKey="users_configurations_allowed_configuration_value_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="users_configurations"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="configuration_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="allowed_configuration_values_configuration_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="configurations"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="value" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="3" name="description" nullable="true" remarks="" size="128" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="allowed_configuration_values_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
      </table>
      <table name="app_controls" numRows="2" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="name" nullable="false" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="1" name="val" nullable="true" remarks="" size="265" type="varchar" typeCode="12"/>
         <index name="app_controls_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="asset_types" numRows="1156" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('asset_types_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="asset_type_id" foreignKey="asset_types_impact_functions_asset_type_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="asset_types_impact_functions"/>
            <child column="asset_type_id" foreignKey="asset_types_metadata_asset_type_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="asset_types_metadata"/>
            <child column="asset_type_id" foreignKey="assets_asset_type_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="assets"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="2" name="descr" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="3" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="true" digits="0" id="5" name="is_active" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="asset_types_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="asset_types_i01" unique="false">
            <column ascending="true" name="is_active"/>
         </index>
         <index name="asset_types_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="asset_types_impact_functions" numRows="625" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="asset_type_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="asset_types_impact_functions_asset_type_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="asset_types"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="impact_function_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="asset_types_impact_functions_impact_function_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="impact_functions"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="risk_factor_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="asset_types_impact_functions_risk_factor_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="risk_factors"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="is_default" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="5" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="asset_type_id" sequenceNumberInPK="1"/>
         <primaryKey column="impact_function_id" sequenceNumberInPK="2"/>
         <index name="asset_types_impact_functions_pkey" unique="true">
            <column ascending="true" name="asset_type_id"/>
            <column ascending="true" name="impact_function_id"/>
         </index>
      </table>
      <table name="asset_types_metadata" numRows="4002" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="asset_type_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="asset_types_metadata_asset_type_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="asset_types"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="metadata_category_id" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="metadata_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="asset_types_metadata_metadata_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="tcs_metadata"/>
         </column>
         <primaryKey column="asset_type_id" sequenceNumberInPK="1"/>
         <primaryKey column="metadata_category_id" sequenceNumberInPK="2"/>
         <index name="asset_types_metadata_pkey" unique="true">
            <column ascending="true" name="asset_type_id"/>
            <column ascending="true" name="metadata_category_id"/>
         </index>
      </table>
      <table name="asset_value_types" numRows="3" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('asset_value_types_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="asset_value_type_id" foreignKey="asset_values_asset_value_type_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="asset_values"/>
            <child column="value_type_id" foreignKey="group_value_types_value_type_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="group_value_types"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="64" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="2" name="system" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="class" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="scale" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="uom" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="asset_value_types_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="asset_value_types_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="asset_values" numRows="8" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('asset_values_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="asset_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="asset_values_asset_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="assets"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="asset_value_type_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="asset_values_asset_value_type_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="asset_value_types"/>
         </column>
         <column autoUpdated="false" defaultValue="0" digits="17" id="3" name="val_nonmonitary" nullable="false" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="0" digits="17" id="4" name="val_monitary" nullable="false" remarks="" size="17" type="float8" typeCode="8"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="asset_values_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="asset_values_c01" unique="true">
            <column ascending="true" name="asset_id"/>
            <column ascending="true" name="asset_value_type_id"/>
         </index>
      </table>
      <table name="assets" numRows="78452" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('assets_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="asset_id" foreignKey="asset_values_asset_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="asset_values"/>
            <child column="asset_id" foreignKey="assets_impact_functions_asset_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="assets_impact_functions"/>
            <child column="asset_id" foreignKey="assets_tags_asset_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="assets_tags"/>
            <child column="asset_id" foreignKey="locations_asset_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="locations"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="investment_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="assets_investment_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="investments"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="asset_type_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="assets_asset_type_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="asset_types"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="name" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="4" name="emissions" nullable="false" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="5" name="notes" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="ownership_weight" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="7" name="asset_value" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="8" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="9" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="1" digits="0" id="10" name="is_active" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="ref_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="assets_ref_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="ref_id"/>
         </column>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="assets_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="assets_c02" unique="true">
            <column ascending="true" name="ref_id"/>
         </index>
         <index name="assets_i01" unique="false">
            <column ascending="true" name="is_active"/>
         </index>
         <index name="assets_i02" unique="false">
            <column ascending="true" name="ref_id"/>
         </index>
      </table>
      <table name="assets_impact_functions" numRows="654369" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('assets_impact_functions_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="asset_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="assets_impact_functions_asset_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="assets"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="impact_function_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="assets_impact_functions_impact_function_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="impact_functions"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="risk_factor_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="assets_impact_functions_risk_factor_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="risk_factors"/>
         </column>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="5" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="assets_impact_functions_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="assets_impact_functions_c01" unique="true">
            <column ascending="true" name="asset_id"/>
            <column ascending="true" name="risk_factor_id"/>
         </index>
      </table>
      <table name="assets_tags" numRows="22144" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="asset_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="assets_tags_asset_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="assets"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="tag_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="assets_tags_tag_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="tags"/>
         </column>
         <primaryKey column="asset_id" sequenceNumberInPK="1"/>
         <primaryKey column="tag_id" sequenceNumberInPK="2"/>
         <index name="assets_tags_pkey" unique="true">
            <column ascending="true" name="asset_id"/>
            <column ascending="true" name="tag_id"/>
         </index>
         <index name="assets_tags_c01" unique="true">
            <column ascending="true" name="tag_id"/>
            <column ascending="true" name="asset_id"/>
         </index>
         <index name="assets_tags_i01" unique="false">
            <column ascending="true" name="asset_id"/>
         </index>
         <index name="assets_tags_i02" unique="false">
            <column ascending="true" name="tag_id"/>
         </index>
      </table>
      <table name="configurations" numRows="18" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('configurations_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="configuration_id" foreignKey="allowed_configuration_values_configuration_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="allowed_configuration_values"/>
            <child column="configuration_id" foreignKey="users_configurations_configuration_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="users_configurations"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="false" digits="0" id="2" name="constrained" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="3" name="data_type" nullable="true" remarks="" size="12" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="4" name="min_value" nullable="true" remarks="" size="8" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="5" name="max_value" nullable="true" remarks="" size="8" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="configurations_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="configurations_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="customer_config" numRows="8" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="customer_id" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="value" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="3" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="customer_id" sequenceNumberInPK="1"/>
         <primaryKey column="name" sequenceNumberInPK="2"/>
         <primaryKey column="value" sequenceNumberInPK="3"/>
         <index name="customer_config_pkey" unique="true">
            <column ascending="true" name="customer_id"/>
            <column ascending="true" name="name"/>
            <column ascending="true" name="value"/>
         </index>
      </table>
      <table name="customers" numRows="938" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('customers_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="customer_id" foreignKey="aggregate_risks_customer_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="aggregate_risks"/>
            <child column="customer_id" foreignKey="groups_customer_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="groups"/>
            <child column="customer_id" foreignKey="ref_id_customer_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="ref_id"/>
            <child column="customer_id" foreignKey="tags_customer_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="tags"/>
            <child column="customer_id" foreignKey="users_roles_customers_customer_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="users_roles_customers"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="customer_status" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="3" name="notes" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="5" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="customers_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="customers_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="customers_assets" numRows="0" remarks="" schema="public" type="VIEW" viewSql=" SELECT DISTINCT assets.id AS asset_id,&#10;    assets.name AS asset_name,&#10;    locations.id AS location_id,&#10;    locations.name AS location_name,&#10;    asset_types.name AS asset_type,&#10;    locations.lng AS longitude,&#10;    locations.lat AS latitude,&#10;    assets.asset_value,&#10;    customers.id AS customer_id,&#10;    customers.name AS customer_name&#10;   FROM (((((((locations&#10;     JOIN assets ON ((locations.asset_id = assets.id)))&#10;     JOIN asset_types ON ((assets.asset_type_id = asset_types.id)))&#10;     JOIN investments ON ((assets.investment_id = investments.id)))&#10;     JOIN folders_investments ON ((investments.id = folders_investments.investment_id)))&#10;     JOIN folders ON ((folders_investments.folder_id = folders.id)))&#10;     JOIN groups ON ((folders.group_id = groups.id)))&#10;     JOIN customers ON ((groups.customer_id = customers.id)));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="asset_id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="asset_name" nullable="true" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="location_id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="location_name" nullable="true" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="asset_type" nullable="true" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="5" name="longitude" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="6" name="latitude" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="7" name="asset_value" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="customer_id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="customer_name" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
      </table>
      <table name="decadal_states" numRows="7749532" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('decadal_states_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="grid_square_id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="point_loc_id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="region_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="decadal_states_region_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="regions"/>
         </column>
         <column autoUpdated="false" defaultValue="1" digits="0" id="4" name="decadal_state_type" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="hazard_metric_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="decadal_states_hazard_metric_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="hazard_metrics"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="scenario_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="decadal_states_scenario_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="scenarios"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="decade" nullable="false" remarks="" size="5" type="int2" typeCode="5"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="8" name="proc_flag_decadal_states_calc" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="9" name="descr" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="10" name="hazard_metric_mean" nullable="false" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="false" digits="0" id="11" name="approximated" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="1" digits="17" id="12" name="approximated_gridsquare_span_lng" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="1" digits="17" id="13" name="approximated_gridsquare_span_lat" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="14" name="not_in_model" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="duplicate_suspected" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="16" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="17" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="18" name="batch_id" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="decadal_states_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="batch_id_i01" unique="false">
            <column ascending="true" name="batch_id"/>
         </index>
         <index name="decadal_states_c03" unique="true">
            <column ascending="true" name="grid_square_id"/>
            <column ascending="true" name="hazard_metric_id"/>
            <column ascending="true" name="scenario_id"/>
            <column ascending="true" name="decade"/>
         </index>
         <index name="decadal_states_c04" unique="true">
            <column ascending="true" name="point_loc_id"/>
            <column ascending="true" name="hazard_metric_id"/>
            <column ascending="true" name="scenario_id"/>
            <column ascending="true" name="decade"/>
         </index>
         <index name="decadal_states_c05" unique="true">
            <column ascending="true" name="region_id"/>
            <column ascending="true" name="hazard_metric_id"/>
            <column ascending="true" name="scenario_id"/>
            <column ascending="true" name="decade"/>
         </index>
         <index name="decadal_states_i01" unique="false">
            <column ascending="true" name="decadal_state_type"/>
         </index>
         <index name="decadal_states_i02" unique="false">
            <column ascending="true" name="decade"/>
         </index>
         <index name="decadal_states_i03" unique="false">
            <column ascending="true" name="grid_square_id"/>
         </index>
         <index name="decadal_states_i04" unique="false">
            <column ascending="true" name="hazard_metric_id"/>
         </index>
         <index name="decadal_states_i05" unique="false">
            <column ascending="true" name="point_loc_id"/>
         </index>
         <index name="decadal_states_i06" unique="false">
            <column ascending="true" name="region_id"/>
         </index>
         <index name="decadal_states_i07" unique="false">
            <column ascending="true" name="proc_flag_decadal_states_calc"/>
         </index>
         <index name="decadal_states_i08_notinmodel" unique="false">
            <column ascending="true" name="not_in_model"/>
         </index>
         <checkConstraint constraint="((proc_flag_decadal_states_calc = ANY (ARRAY['-1'::integer, 0, 1])))" name="decadal_states_c01"/>
         <checkConstraint constraint="((decade = ANY (ARRAY[0, 2010, 2020, 2030, 2040, 2050, 2060, 2070, 2080, 2090, 2100])))" name="decadal_states_c02"/>
      </table>
      <table name="decadal_states_batch" numRows="0" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('decadal_states_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="grid_square_id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="point_loc_id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="region_id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="1" digits="0" id="4" name="decadal_state_type" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="hazard_metric_id" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="scenario_id" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="decade" nullable="false" remarks="" size="5" type="int2" typeCode="5"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="8" name="proc_flag_decadal_states_calc" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="9" name="descr" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="10" name="hazard_metric_mean" nullable="false" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="false" digits="0" id="11" name="approximated" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="1" digits="17" id="12" name="approximated_gridsquare_span_lng" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="1" digits="17" id="13" name="approximated_gridsquare_span_lat" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="14" name="not_in_model" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="duplicate_suspected" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="16" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="17" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="18" name="batch_id" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="decadal_states_batch_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="decadal_states_batch_decadal_state_type_idx" unique="false">
            <column ascending="true" name="decadal_state_type"/>
         </index>
         <index name="decadal_states_batch_decade_idx" unique="false">
            <column ascending="true" name="decade"/>
         </index>
         <index name="decadal_states_batch_grid_square_id_hazard_metric_id_scenar_key" unique="true">
            <column ascending="true" name="grid_square_id"/>
            <column ascending="true" name="hazard_metric_id"/>
            <column ascending="true" name="scenario_id"/>
            <column ascending="true" name="decade"/>
         </index>
         <index name="decadal_states_batch_grid_square_id_idx" unique="false">
            <column ascending="true" name="grid_square_id"/>
         </index>
         <index name="decadal_states_batch_hazard_metric_id_idx" unique="false">
            <column ascending="true" name="hazard_metric_id"/>
         </index>
         <index name="decadal_states_batch_not_in_model_idx" unique="false">
            <column ascending="true" name="not_in_model"/>
         </index>
         <index name="decadal_states_batch_point_loc_id_hazard_metric_id_scenario_key" unique="true">
            <column ascending="true" name="point_loc_id"/>
            <column ascending="true" name="hazard_metric_id"/>
            <column ascending="true" name="scenario_id"/>
            <column ascending="true" name="decade"/>
         </index>
         <index name="decadal_states_batch_point_loc_id_idx" unique="false">
            <column ascending="true" name="point_loc_id"/>
         </index>
         <index name="decadal_states_batch_proc_flag_decadal_states_calc_idx" unique="false">
            <column ascending="true" name="proc_flag_decadal_states_calc"/>
         </index>
         <index name="decadal_states_batch_region_id_hazard_metric_id_scenario_id_key" unique="true">
            <column ascending="true" name="region_id"/>
            <column ascending="true" name="hazard_metric_id"/>
            <column ascending="true" name="scenario_id"/>
            <column ascending="true" name="decade"/>
         </index>
         <index name="decadal_states_batch_region_id_idx" unique="false">
            <column ascending="true" name="region_id"/>
         </index>
         <checkConstraint constraint="((proc_flag_decadal_states_calc = ANY (ARRAY['-1'::integer, 0, 1])))" name="decadal_states_c01"/>
         <checkConstraint constraint="((decade = ANY (ARRAY[0, 2010, 2020, 2030, 2040, 2050, 2060, 2070, 2080, 2090, 2100])))" name="decadal_states_c02"/>
      </table>
      <table name="derived_vars" numRows="342" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('derived_vars_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="risk_factor_id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="hazard_metric_id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="is_primary" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="derived_vars_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
      </table>
      <table name="etl_gridded_data" numRows="120" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="etl_batch" nullable="false" remarks="" size="16" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="etl_hazard_metric_name" nullable="false" remarks="" size="16" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="etl_scenario_name" nullable="false" remarks="" size="16" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="etl_grid_system_name" nullable="false" remarks="" size="16" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="etl_grid_square_serial_lngid" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="etl_grid_square_serial_latid" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="6" name="etl_grid_square_name" nullable="true" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="decade" nullable="false" remarks="" size="5" type="int2" typeCode="5"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="8" name="hazard_metric_mean" nullable="false" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="9" name="proc_stage_complete" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <index name="etl_gridded_data_c01" unique="true">
            <column ascending="true" name="etl_batch"/>
            <column ascending="true" name="etl_hazard_metric_name"/>
            <column ascending="true" name="etl_scenario_name"/>
            <column ascending="true" name="etl_grid_square_name"/>
            <column ascending="true" name="decade"/>
         </index>
         <index name="etl_gridded_data_i01" unique="false">
            <column ascending="true" name="etl_batch"/>
         </index>
         <index name="etl_gridded_data_i02" unique="false">
            <column ascending="true" name="etl_hazard_metric_name"/>
         </index>
         <index name="etl_gridded_data_i03" unique="false">
            <column ascending="true" name="etl_scenario_name"/>
         </index>
         <index name="etl_gridded_data_i04" unique="false">
            <column ascending="true" name="etl_grid_system_name"/>
         </index>
         <index name="etl_gridded_data_i05" unique="false">
            <column ascending="true" name="etl_grid_square_name"/>
         </index>
         <index name="etl_gridded_data_i06" unique="false">
            <column ascending="true" name="decade"/>
         </index>
      </table>
      <table name="flyway_schema_history" numRows="136" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="installed_rank" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="1" name="version" nullable="true" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="description" nullable="false" remarks="" size="200" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="type" nullable="false" remarks="" size="20" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="script" nullable="false" remarks="" size="1000" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="checksum" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="installed_by" nullable="false" remarks="" size="100" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="7" name="installed_on" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="execution_time" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="success" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <primaryKey column="installed_rank" sequenceNumberInPK="1"/>
         <index name="flyway_schema_history_pkey" unique="true">
            <column ascending="true" name="installed_rank"/>
         </index>
         <index name="flyway_schema_history_s_idx" unique="false">
            <column ascending="true" name="success"/>
         </index>
      </table>
      <table name="folders" numRows="311" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('folders_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="folder_id" foreignKey="folders_investments_folder_id_fkey" implied="false" onDeleteCascade="true" schema="public" table="folders_investments"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="group_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="folders_group_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="groups"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name" nullable="false" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="3" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="folders_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="folders_c01" unique="true">
            <column ascending="true" name="group_id"/>
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="folders_investments" numRows="2911" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="folder_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="folders_investments_folder_id_fkey" implied="false" onDeleteCascade="true" schema="public" table="folders"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="investment_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="folders_investments_investment_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="investments"/>
         </column>
         <primaryKey column="folder_id" sequenceNumberInPK="1"/>
         <primaryKey column="investment_id" sequenceNumberInPK="2"/>
         <index name="folders_investments_pkey" unique="true">
            <column ascending="true" name="folder_id"/>
            <column ascending="true" name="investment_id"/>
         </index>
      </table>
      <table name="grid_squares" numRows="698835" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('grid_squares_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="grid_square_id" foreignKey="loc_grid_squares_grid_square_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="loc_grid_squares"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="grid_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="grid_squares_grid_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="grids"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="serial_lngid" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="serial_latid" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="name_etl" nullable="false" remarks="" size="16" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="5" name="lat_centroid" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="6" name="lng_centroid" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="7" name="lat_high" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="8" name="lat_low" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="9" name="lng_left" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="10" name="lng_right" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="11" name="version" nullable="true" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="12" name="proc_flag_gridsquare_has_current_data" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="grid_squares_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="grid_squares_c01" unique="true">
            <column ascending="true" name="grid_id"/>
            <column ascending="true" name="serial_lngid"/>
            <column ascending="true" name="serial_latid"/>
         </index>
         <index name="grid_squares_i01" unique="false">
            <column ascending="true" name="name_etl"/>
         </index>
         <index name="grid_squares_i02" unique="true">
            <column ascending="true" name="grid_id"/>
            <column ascending="true" name="serial_lngid"/>
            <column ascending="true" name="serial_latid"/>
         </index>
         <index name="grid_squares_i03_version" unique="false">
            <column ascending="true" name="version"/>
         </index>
         <index name="grid_squares_i04_procflag" unique="false">
            <column ascending="true" name="proc_flag_gridsquare_has_current_data"/>
         </index>
      </table>
      <table name="grids" numRows="2" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('grids_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="grid_id" foreignKey="grid_squares_grid_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="grid_squares"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name_etl" nullable="false" remarks="" size="16" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="resolution_km" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="4" name="resolution_deg" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="1" digits="0" id="5" name="resolution_type" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="100" digits="0" id="6" name="priority" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="grids_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="grids_i01" unique="false">
            <column ascending="true" name="name_etl"/>
         </index>
         <index name="grids_name_etl_key" unique="true">
            <column ascending="true" name="name_etl"/>
         </index>
         <index name="grids_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <checkConstraint constraint="((resolution_type = ANY (ARRAY[0, 1])))" name="grids_c01"/>
      </table>
      <table name="group_value_types" numRows="0" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('group_value_types_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="group_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="group_value_types_group_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="groups"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="value_type_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="group_value_types_value_type_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="asset_value_types"/>
         </column>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="group_value_types_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="group_value_types_c01" unique="true">
            <column ascending="true" name="group_id"/>
            <column ascending="true" name="value_type_id"/>
         </index>
      </table>
      <table name="groups" numRows="150" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('groups_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="group_id" foreignKey="folders_group_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="folders"/>
            <child column="group_id" foreignKey="group_value_types_group_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="group_value_types"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="customer_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="groups_customer_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="customers"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name" nullable="false" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="3" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="groups_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="groups_c01" unique="true">
            <column ascending="true" name="customer_id"/>
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="hazard_metrics" numRows="15" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('hazard_metrics_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="hazard_metric_id" foreignKey="aggregate_risks_hazard_metric_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="aggregate_risks"/>
            <child column="hazard_metric_id" foreignKey="decadal_states_hazard_metric_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="decadal_states"/>
            <child column="hazard_metric_id" foreignKey="impact_functions_hazard_metric_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="impact_functions"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name_etl" nullable="false" remarks="" size="16" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="risk_factor_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="hazard_metrics_risk_factor_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="risk_factors"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="icon_name" nullable="false" remarks="" size="64" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="icon_color" nullable="false" remarks="" size="64" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="1" digits="0" id="6" name="class" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="uom" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="8" name="descr" nullable="true" remarks="" size="2048" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="9" name="notes" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="false" digits="0" id="10" name="do_not_approximate" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="11" name="y_label" nullable="true" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="12" name="hazard_label" nullable="true" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="13" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="14" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="15" name="msg_no_data_available" nullable="true" remarks="" size="512" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="true" digits="0" id="16" name="is_active" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="hazard_metrics_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="hazard_metrics_i01" unique="false">
            <column ascending="true" name="name_etl"/>
         </index>
         <index name="hazard_metrics_name_etl_key" unique="true">
            <column ascending="true" name="name_etl"/>
         </index>
         <index name="hazard_metrics_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <checkConstraint constraint="((class = ANY (ARRAY[1, 2, 3, 4, 5, 6, 100])))" name="hazard_metrics_c01"/>
      </table>
      <table name="impact_functions" numRows="3261" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('impact_functions_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="impact_function_id" foreignKey="asset_types_impact_functions_impact_function_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="asset_types_impact_functions"/>
            <child column="impact_function_id" foreignKey="assets_impact_functions_impact_function_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="assets_impact_functions"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="hazard_metric_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="impact_functions_hazard_metric_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="hazard_metrics"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="risk_factor_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="impact_functions_risk_factor_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="risk_factors"/>
         </column>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="4" name="source" nullable="true" remarks="" size="64" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="5" name="descr" nullable="true" remarks="" size="2048" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="xmetric" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="xunits" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="xaxislabel" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="ymetric" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="yunits" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="yaxislabel" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="12" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="author" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="14" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="modifier" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="1" digits="0" id="16" name="scoring_method" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="17" name="proc_flag_risks_calc" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="18" name="notes" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="impact_functions_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="impact_functions_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <checkConstraint constraint="((proc_flag_risks_calc = ANY (ARRAY['-1'::integer, 0, 1])))" name="impact_functions_c01"/>
      </table>
      <table name="impact_pathways" numRows="5279" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('impact_pathways_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="impact_pathway_id" foreignKey="risks_impact_pathway_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="risks"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="impact_function_id" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="list_xvalues" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="list_yvalues" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="5" name="proc_flag_risks_calc" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="6" name="notes" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="7" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="8" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="impact_pathways_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="impact_pathways_c01" unique="true">
            <column ascending="true" name="impact_function_id"/>
            <column ascending="true" name="name"/>
         </index>
         <checkConstraint constraint="((proc_flag_risks_calc = ANY (ARRAY['-1'::integer, 0, 1])))" name="impact_pathways_c02"/>
      </table>
      <table name="investments" numRows="2996" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('investments_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="investment_id" foreignKey="assets_investment_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="assets"/>
            <child column="investment_id" foreignKey="folders_investments_investment_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="folders_investments"/>
         </column>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="1" name="sector_id" nullable="true" remarks="" size="18" type="varchar" typeCode="12">
            <parent column="id" foreignKey="investments_sector_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="sectors"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name" nullable="false" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="3" name="exchange_name" nullable="true" remarks="" size="64" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="4" name="ticker_symbol" nullable="true" remarks="" size="10" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="5" name="earnings" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="location_count" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="7" name="tot_val_tx90p" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="8" name="tot_val_pdsisc" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="9" name="tot_val_coastalflood" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="10" name="tot_val_carbonprice" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="11" name="tot_val_zindex" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="12" name="notes" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="13" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="14" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="investments_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
      </table>
      <table name="loc_grid_squares" numRows="81221" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('loc_grid_squares_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="loc_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="loc_grid_squares_loc_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="locations"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="grid_square_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="loc_grid_squares_grid_square_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="grid_squares"/>
         </column>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="loc_grid_squares_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="loc_grid_squares_c01" unique="true">
            <column ascending="true" name="loc_id"/>
            <column ascending="true" name="grid_square_id"/>
         </index>
      </table>
      <table name="loc_regions" numRows="79140" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('loc_regions_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="loc_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="loc_regions_loc_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="locations"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="region_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="loc_regions_region_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="regions"/>
         </column>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="loc_regions_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="loc_regions_c01" unique="true">
            <column ascending="true" name="loc_id"/>
         </index>
      </table>
      <table name="locations" numRows="81629" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('locations_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="loc_id" foreignKey="loc_grid_squares_loc_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="loc_grid_squares"/>
            <child column="loc_id" foreignKey="loc_regions_loc_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="loc_regions"/>
            <child column="location_id" foreignKey="risks_location_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="risks"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="asset_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="locations_asset_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="assets"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="3" name="lng" nullable="false" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="4" name="lat" nullable="false" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="5" name="notes" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="6" name="elevation_m_rel2lmsl" nullable="false" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="7" name="address_1" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="8" name="address_2" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="9" name="address_3" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="10" name="admin_area_level0" nullable="true" remarks="" size="64" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="11" name="admin_area_level1" nullable="true" remarks="" size="64" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="12" name="admin_area_level2" nullable="true" remarks="" size="64" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="13" name="proc_flag_loc_eval_risks" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="14" name="proc_flag_loc_assign_gridded" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="15" name="proc_flag_loc_assign_segmented" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="16" name="proc_flag_loc_assign_point" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="17" name="proc_flag_loc_assign_regional" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="18" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="19" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="20" name="ref_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="locations_ref_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="ref_id"/>
         </column>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="locations_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="locactions_i07" unique="false">
            <column ascending="true" name="proc_flag_loc_assign_point"/>
         </index>
         <index name="locations_c01" unique="true">
            <column ascending="true" name="asset_id"/>
            <column ascending="true" name="name"/>
            <column ascending="true" name="ref_id"/>
         </index>
         <index name="locations_i01" unique="false">
            <column ascending="true" name="admin_area_level0"/>
         </index>
         <index name="locations_i02" unique="false">
            <column ascending="true" name="admin_area_level1"/>
         </index>
         <index name="locations_i03" unique="false">
            <column ascending="true" name="admin_area_level2"/>
         </index>
         <index name="locations_i04" unique="false">
            <column ascending="true" name="proc_flag_loc_eval_risks"/>
         </index>
         <index name="locations_i05" unique="false">
            <column ascending="true" name="proc_flag_loc_assign_gridded"/>
         </index>
         <index name="locations_i06" unique="false">
            <column ascending="true" name="proc_flag_loc_assign_segmented"/>
         </index>
         <index name="locations_i07" unique="false">
            <column ascending="true" name="proc_flag_loc_assign_point"/>
         </index>
         <index name="locations_i08" unique="false">
            <column ascending="true" name="proc_flag_loc_assign_regional"/>
         </index>
         <index name="locations_i09" unique="false">
            <column ascending="true" name="name"/>
         </index>
         <index name="locations_i10" unique="false">
            <column ascending="true" name="ref_id"/>
         </index>
         <checkConstraint constraint="((proc_flag_loc_assign_gridded = ANY (ARRAY['-1'::integer, 0, 1])))" name="locations_c02"/>
         <checkConstraint constraint="((proc_flag_loc_assign_segmented = ANY (ARRAY['-1'::integer, 0, 1])))" name="locations_c03"/>
         <checkConstraint constraint="((proc_flag_loc_eval_risks = ANY (ARRAY['-1'::integer, 0, 1])))" name="locations_c04"/>
         <checkConstraint constraint="((proc_flag_loc_assign_point = ANY (ARRAY['-2'::integer, '-1'::integer, 0, 1])))" name="locations_c05"/>
         <checkConstraint constraint="((proc_flag_loc_assign_regional = ANY (ARRAY['-1'::integer, 0, 1])))" name="locations_c06"/>
      </table>
      <table name="ref_id" numRows="140067" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('ref_id_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="ref_id" foreignKey="assets_ref_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="assets"/>
            <child column="ref_id" foreignKey="locations_ref_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="locations"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="customer_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="ref_id_customer_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="customers"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="ref_name" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="1" digits="0" id="3" name="is_active" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="4" name="ref_type" nullable="true" remarks="" size="255" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="ref_id_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="ref_id_i01" unique="false">
            <column ascending="true" name="is_active"/>
         </index>
      </table>
      <table name="region_areas" numRows="234" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('region_areas_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="region_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="region_areas_region_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="regions"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name_admin0" nullable="false" remarks="" size="64" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="region_areas_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="region_areas_i01" unique="false">
            <column ascending="true" name="name_admin0"/>
         </index>
      </table>
      <table name="regions" numRows="5" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('regions_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="region_id" foreignKey="decadal_states_region_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="decadal_states"/>
            <child column="region_id" foreignKey="loc_regions_region_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="loc_regions"/>
            <child column="region_id" foreignKey="region_areas_region_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="region_areas"/>
         </column>
         <column autoUpdated="false" defaultValue="1" digits="0" id="1" name="reg_system" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name_etl" nullable="false" remarks="" size="64" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="regions_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="regions_i01" unique="false">
            <column ascending="true" name="name_etl"/>
         </index>
         <index name="regions_name_etl_key" unique="true">
            <column ascending="true" name="name_etl"/>
         </index>
      </table>
      <table name="rf_categories" numRows="14" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('rf_categories_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="rf_category_id" foreignKey="rf_category_risk_factors_rf_category_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="rf_category_risk_factors"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="rf_category_hierarchy_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="rf_categories_rf_category_hierarchy_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="rf_category_hierarchies"/>
         </column>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="2" name="name" nullable="true" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="parent_id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="rf_categories_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="rf_categories_c01" unique="true">
            <column ascending="true" name="rf_category_hierarchy_id"/>
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="rf_category_hierarchies" numRows="1" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('rf_category_hierarchies_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="rf_category_hierarchy_id" foreignKey="rf_categories_rf_category_hierarchy_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="rf_categories"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="rf_category_hierarchies_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="rf_category_hierarchies_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="rf_category_risk_factors" numRows="17" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('rf_category_risk_factors_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="rf_category_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="rf_category_risk_factors_rf_category_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="rf_categories"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="risk_factor_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="rf_category_risk_factors_risk_factor_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="risk_factors"/>
         </column>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="rf_category_risk_factors_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="rf_category_risk_factors_c01" unique="true">
            <column ascending="true" name="rf_category_id"/>
            <column ascending="true" name="risk_factor_id"/>
         </index>
      </table>
      <table name="risk_factors" numRows="17" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="risk_factor_id" foreignKey="aggregate_impacts_risk_factor_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="aggregate_impacts"/>
            <child column="risk_factor_id" foreignKey="aggregate_risks_risk_factor_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="aggregate_risks"/>
            <child column="risk_factor_id" foreignKey="asset_types_impact_functions_risk_factor_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="asset_types_impact_functions"/>
            <child column="risk_factor_id" foreignKey="assets_impact_functions_risk_factor_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="assets_impact_functions"/>
            <child column="risk_factor_id" foreignKey="hazard_metrics_risk_factor_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="hazard_metrics"/>
            <child column="risk_factor_id" foreignKey="impact_functions_risk_factor_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="impact_functions"/>
            <child column="risk_factor_id" foreignKey="rf_category_risk_factors_risk_factor_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="rf_category_risk_factors"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="2" name="descr" nullable="true" remarks="" size="2048" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="3" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="risk_factors_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="risk_factors_i01_name" unique="false">
            <column ascending="true" name="name"/>
         </index>
         <index name="risk_factors_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="risks" numRows="28657312" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('risks_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="19" type="bigserial" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="location_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="risks_location_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="locations"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="impact_pathway_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="risks_impact_pathway_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="impact_pathways"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="scenario_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="risks_scenario_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="scenarios"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="yr" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="5" name="portion_at_risk" nullable="false" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="6" name="is_deleted" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="7" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="8" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="batch_id" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="risks_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="risks_c01" unique="true">
            <column ascending="true" name="location_id"/>
            <column ascending="true" name="impact_pathway_id"/>
            <column ascending="true" name="scenario_id"/>
            <column ascending="true" name="yr"/>
         </index>
      </table>
      <table name="roles" numRows="3" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('roles_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="role_id" foreignKey="roles_scopes_role_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="roles_scopes"/>
            <child column="role_id" foreignKey="users_roles_customers_role_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="users_roles_customers"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="2" name="description" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="3" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="roles_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="roles_i01" unique="false">
            <column ascending="true" name="name"/>
         </index>
         <index name="roles_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="roles_scopes" numRows="52" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('roles_scopes_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="role_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="roles_scopes_role_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="roles"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="scope_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="roles_scopes_scope_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="scopes"/>
         </column>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="3" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="roles_scopes_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="roles_scopes_c01" unique="true">
            <column ascending="true" name="role_id"/>
            <column ascending="true" name="scope_id"/>
         </index>
      </table>
      <table name="scenarios" numRows="4" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('scenarios_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="scenario_id" foreignKey="aggregate_impacts_scenario_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="aggregate_impacts"/>
            <child column="scenario_id" foreignKey="aggregate_risks_scenario_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="aggregate_risks"/>
            <child column="scenario_id" foreignKey="decadal_states_scenario_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="decadal_states"/>
            <child column="scenario_id" foreignKey="risks_scenario_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="risks"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name_etl" nullable="false" remarks="" size="16" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="3" name="proc_flag_risks_calc" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="4" name="descr" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="scenarios_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="scenarios_i01" unique="false">
            <column ascending="true" name="name_etl"/>
         </index>
         <index name="scenarios_name_etl_key" unique="true">
            <column ascending="true" name="name_etl"/>
         </index>
         <index name="scenarios_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <checkConstraint constraint="((proc_flag_risks_calc = ANY (ARRAY['-1'::integer, 0, 1])))" name="scenarios_c01"/>
      </table>
      <table name="scopes" numRows="28" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('scopes_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="scope_id" foreignKey="roles_scopes_scope_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="roles_scopes"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="2" name="description" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="3" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="scopes_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="scopes_i01" unique="false">
            <column ascending="true" name="name"/>
         </index>
         <index name="scopes_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="sectors" numRows="12" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="18" type="varchar" typeCode="12">
            <child column="sector_id" foreignKey="investments_sector_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="investments"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="2" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="3" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="sectors_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="sectors_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="tags" numRows="339" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('tags_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="tag_id" foreignKey="assets_tags_tag_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="assets_tags"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="customer_id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="tags_customer_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="customers"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name" nullable="false" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="3" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="tags_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="tags_c01" unique="true">
            <column ascending="true" name="customer_id"/>
            <column ascending="true" name="name"/>
         </index>
         <index name="tags_i01" unique="false">
            <column ascending="true" name="name"/>
         </index>
         <index name="tags_i02" unique="false">
            <column ascending="true" name="customer_id"/>
         </index>
      </table>
      <table name="tcs_metadata" numRows="31" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('tcs_metadata_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="metadata_id" foreignKey="asset_types_metadata_metadata_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="asset_types_metadata"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="category_id" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="category_name" nullable="false" remarks="" size="64" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="value" nullable="false" remarks="" size="64" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="4" name="description" nullable="true" remarks="" size="1024" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="tcs_metadata_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="tcs_metadata_value_key" unique="true">
            <column ascending="true" name="value"/>
         </index>
      </table>
      <table name="updates" numRows="39009" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('updates_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="entity_type" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="entity_id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="action" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="4" name="scoring_status" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="0" digits="0" id="5" name="aggregation_status" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="customer_id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="7" name="user_id" nullable="true" remarks="" size="128" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_ts" nullable="true" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="update_details" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="10" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="11" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="updates_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="updates_c01" unique="true">
            <column ascending="true" name="entity_type"/>
            <column ascending="true" name="entity_id"/>
            <column ascending="true" name="action"/>
         </index>
         <index name="updates_i01" unique="false">
            <column ascending="true" name="entity_type"/>
         </index>
         <index name="updates_i02" unique="false">
            <column ascending="true" name="entity_id"/>
         </index>
         <index name="updates_i03" unique="false">
            <column ascending="true" name="action"/>
         </index>
         <index name="updates_i04" unique="false">
            <column ascending="true" name="scoring_status"/>
         </index>
         <index name="updates_i05" unique="false">
            <column ascending="true" name="aggregation_status"/>
         </index>
         <index name="updates_i06" unique="false">
            <column ascending="true" name="customer_id"/>
         </index>
         <index name="updates_i07" unique="false">
            <column ascending="true" name="user_id"/>
         </index>
         <index name="updates_i08" unique="false">
            <column ascending="true" name="update_ts"/>
         </index>
      </table>
      <table name="users" numRows="11" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('users_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="user_id" foreignKey="users_configurations_user_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="users_configurations"/>
            <child column="user_id" foreignKey="users_roles_customers_user_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="users_roles_customers"/>
         </column>
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="1" name="guid" nullable="false" remarks="" size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name" nullable="false" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="email" nullable="false" remarks="" size="255" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="5" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="true" digits="0" id="6" name="is_active" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="users_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="users_c01" unique="true">
            <column ascending="true" name="email"/>
         </index>
         <index name="users_i01" unique="false">
            <column ascending="true" name="email"/>
         </index>
      </table>
      <table name="users_configurations" numRows="11" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('users_configurations_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="user_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="users_configurations_user_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="users"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="configuration_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="users_configurations_configuration_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="configurations"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="allowed_configuration_value_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="users_configurations_allowed_configuration_value_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="allowed_configuration_values"/>
         </column>
         <column autoUpdated="false" defaultValue="NULL::character varying" digits="0" id="4" name="unconstrained_value" nullable="true" remarks="" size="32" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="users_configurations_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
      </table>
      <table name="users_roles_customers" numRows="12" remarks="" schema="public" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('users_roles_customers_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="user_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="users_roles_customers_user_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="users"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="role_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="users_roles_customers_role_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="roles"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="customer_id" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="users_roles_customers_customer_id_fkey" implied="false" onDeleteCascade="false" schema="public" table="customers"/>
         </column>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="created_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="5" name="updated_at" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="true" digits="0" id="6" name="is_active" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="users_roles_customers_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="users_roles_customers_c01" unique="true">
            <column ascending="true" name="user_id"/>
            <column ascending="true" name="customer_id"/>
         </index>
      </table>
   </tables>
   <routines>
      <routine dataAccess="MODIFIES" deterministic="false" name="activate_asset" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
UPDATE assets SET is_active=1 WHERE id=this_asset_id; -- Set flag
	SELECT score_asset(this_asset_id); -- Score and aggregate the asset
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="aggregates_update" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	rec RECORD;
	total integer;
	-- parent_entity_id integer;
BEGIN
	IF this_aggregate_level = 3 THEN -- Investment
		PERFORM investment_aggregates_update_totals(this_entity_id);
		SELECT COUNT(*) INTO total FROM assets WHERE investment_id=this_entity_id AND assets.is_active = 1; -- How many assets this investment
		SELECT * INTO rec FROM aggregate_totals
			WHERE aggregate_level=this_aggregate_level AND tags_hash_md5=MD5('') AND entity_id=this_entity_id;
		IF rec.qty_assets_complete_risks=total -- Only if all assets in this investment are scored
			AND rec.qty_assets_complete_hazards=total THEN
			PERFORM investment_aggregates_update_impacts(this_entity_id);
		END IF;
		-- Call the level above: Folder
		FOR rec IN SELECT DISTINCT folder_id -- For each folder containing this investment
			FROM folders_investments WHERE investment_id=this_entity_id LOOP
			PERFORM aggregates_update(this_aggregate_level + 1, rec.folder_id);
		END LOOP;
	ELSIF this_aggregate_level = 4 THEN -- Folder
		PERFORM folder_aggregates_update_totals(this_entity_id);
		SELECT COUNT(DISTINCT assets.id) INTO total -- How many distinct assets this folder
			FROM ((folders_investments
				INNER JOIN investments ON folders_investments.investment_id=investments.id)
				INNER JOIN assets ON investments.id=assets.investment_id)
			WHERE folders_investments.folder_id=this_entity_id AND assets.is_active = 1;
		SELECT * INTO rec FROM aggregate_totals
			WHERE aggregate_level=this_aggregate_level AND tags_hash_md5=MD5('') AND entity_id=this_entity_id;
		IF rec.qty_assets_complete_risks=total -- Only if all assets in this folder are scored
			AND rec.qty_assets_complete_hazards=total THEN
			PERFORM folder_aggregates_update_impacts(this_entity_id);
		END IF;
		-- Call the level above: Group
		FOR rec IN SELECT DISTINCT group_id -- For the parent group of this folder
			FROM folders WHERE id=this_entity_id LOOP
			PERFORM aggregates_update(this_aggregate_level + 1, rec.group_id);
		END LOOP;
	ELSIF this_aggregate_level = 5 THEN -- Group
		PERFORM group_aggregates_update_totals(this_entity_id);
		SELECT COUNT(DISTINCT assets.id) INTO total -- How many distinct assets this group
			FROM (((folders
				INNER JOIN folders_investments ON folders.id=folders_investments.folder_id)
				INNER JOIN investments ON folders_investments.investment_id=investments.id)
				INNER JOIN assets ON investments.id=assets.investment_id)
			WHERE folders.group_id=this_entity_id AND assets.is_active = 1;
		SELECT * INTO rec FROM aggregate_totals
			WHERE aggregate_level=this_aggregate_level AND tags_hash_md5=MD5('') AND entity_id=this_entity_id;
		IF rec.qty_assets_complete_risks=total -- Only if all assets in this group are scored
			AND rec.qty_assets_complete_hazards=total THEN
			PERFORM group_aggregates_update_impacts(this_entity_id);
		END IF;
		-- Call the level above: Customer
		FOR rec IN SELECT DISTINCT customer_id -- For the parent customer of this group
			FROM groups WHERE id=this_entity_id LOOP
			PERFORM aggregates_update(this_aggregate_level + 1, rec.customer_id);
		END LOOP;
	ELSIF this_aggregate_level = 6 THEN -- Customer
		PERFORM customer_aggregates_update_totals(this_entity_id);
		SELECT COUNT(DISTINCT assets.id) INTO total -- How many distinct assets this customer
			FROM ((((groups
				INNER JOIN folders ON groups.id=folders.group_id)
				INNER JOIN folders_investments ON folders.id=folders_investments.folder_id)
				INNER JOIN investments ON folders_investments.investment_id=investments.id)
				INNER JOIN assets ON investments.id=assets.investment_id)
			WHERE groups.customer_id=this_entity_id AND assets.is_active = 1;
		SELECT * INTO rec FROM aggregate_totals
			WHERE aggregate_level=this_aggregate_level AND tags_hash_md5=MD5('') AND entity_id=this_entity_id;
		IF rec.qty_assets_complete_risks=total -- Only if all assets in this customer are scored
			AND rec.qty_assets_complete_hazards=total THEN
			PERFORM customer_aggregates_update_impacts(this_entity_id);
		END IF; -- No more levels above.
	END IF;
	RETURN;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_aggregates_update" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	total_done INTEGER;
	total_locs INTEGER;
    t timestamptz := clock_timestamp();
BEGIN
	RAISE NOTICE 'Asset: %', this_asset_id;
	SELECT COUNT(*) INTO total_locs FROM locations WHERE asset_id=this_asset_id;
	SELECT COUNT(*) INTO total_done FROM locations WHERE asset_id=this_asset_id
		AND proc_flag_loc_eval_risks=1 AND proc_flag_loc_assign_gridded=1
		AND proc_flag_loc_assign_point=1 AND proc_flag_loc_assign_segmented=1
		AND proc_flag_loc_assign_regional=1;
	IF total_done=total_locs THEN -- If all the locs in this asset are done
		PERFORM asset_aggregates_update_totals(this_asset_id); -- Update totals/completeness
		PERFORM asset_aggregates_update_impacts(this_asset_id);
		-- PERFORM aggregates_update(3, assets.investment_id) FROM assets WHERE id=this_asset_id; -- Disabled by SD 05232021 For next level (investment)
	END IF;
    RAISE NOTICE 'asset_aggregates_update execution duration: %', clock_timestamp() - t;
	RETURN;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_aggregates_update_impacts" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
-- Clear existing
DELETE FROM aggregate_impacts WHERE aggregate_level=2 AND entity_id=this_asset_id;
-- Insert impact rows
INSERT INTO aggregate_impacts (aggregate_level, entity_id, tags_hash_md5, risk_factor_id, scenario_id, yr, impact_abs)
SELECT 2 AS level, locations.asset_id, md5(combos.tags_combo), impact_functions.risk_factor_id, risks.scenario_id,
	risks.yr, asset_impact_to_fmv_by_scenario_decade_riskfactor(locations.asset_id, risks.scenario_id, risks.yr, impact_functions.risk_factor_id)
FROM (((risks INNER JOIN locations ON risks.location_id=locations.id)
	INNER JOIN impact_pathways ON risks.impact_pathway_id=impact_pathways.id)
	INNER JOIN impact_functions ON impact_pathways.impact_function_id=impact_functions.id)
CROSS JOIN (SELECT * FROM asset_tags_combinations(this_asset_id)) as combos
WHERE locations.asset_id=this_asset_id
GROUP BY locations.asset_id, combos.tags_combo, impact_functions.risk_factor_id, risks.scenario_id, risks.yr;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_aggregates_update_totals" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	old_parent_id integer := 0;
	new_parent_id integer := 0;
BEGIN
	-- Get previous and current parent investments
	SELECT parent_entity_id INTO old_parent_id
		FROM aggregate_totals WHERE aggregate_level=2 AND entity_id=this_asset_id AND tags_hash_md5=md5('');
	SELECT investment_id INTO new_parent_id FROM assets WHERE id=this_asset_id;
	-- Clear existing
	DELETE FROM aggregate_totals WHERE aggregate_level=2 AND entity_id=this_asset_id;
	-- Determine whether asset has moved
	IF old_parent_id != new_parent_id THEN -- Asset has moved.
		RAISE NOTICE 'Asset moved from investment % to investment %', old_parent_id, new_parent_id;
		-- PERFORM aggregates_update(3, old_parent_id); -- Aggregate old investment.
	END IF;
	-- Insert totals row
	INSERT INTO aggregate_totals (aggregate_level, entity_id, parent_entity_id, tags_hash_md5, qty_children, qty_children_done,
								  value_abs, qty_assets, qty_assets_complete_hazards, qty_assets_complete_risks)
	SELECT 2 AS level, this_asset_id, assets.investment_id, md5(combos.tags_combo), asset_qty_locations(this_asset_id),
		asset_qty_locations(this_asset_id) * asset_is_complete_hazards(this_asset_id) * asset_is_complete_risks(this_asset_id), -- qty of locs X 0,1 hazards X 0,1 risks
		asset_value, 1 AS qty_assets, asset_is_complete_hazards(this_asset_id), asset_is_complete_risks(this_asset_id)
	FROM assets
	CROSS JOIN (SELECT * FROM asset_tags_combinations(this_asset_id)) as combos
	WHERE assets.id=this_asset_id;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_flag_to_eval" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT loc_flag_to_eval(locations.id) FROM locations WHERE asset_id=this_entity_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_hazard_metric_mean_by_scenario_decade_riskfactor" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT COALESCE(asset_hazard_metric_mean_gridded_by_scenario_decade_riskfactor(this_asset_id,this_scen_id,this_decade,this_risk_factor_id),
			   asset_hazard_metric_mean_point_by_scenario_decade_riskfactor(this_asset_id,this_scen_id,this_decade,this_risk_factor_id),
			   asset_hazard_metric_mean_regional_by_scenario_decade_riskfactor(this_asset_id,this_scen_id,this_decade,this_risk_factor_id));
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_hazard_metric_mean_gridded_by_scenario_decade_riskfactor" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT CAST(AVG(hazard_metric_mean) AS numeric)
FROM ((((decadal_states
	INNER JOIN loc_grid_squares ON decadal_states.grid_square_id=loc_grid_squares.grid_square_id)
	INNER JOIN locations ON loc_grid_squares.loc_id=locations.id)
	INNER JOIN assets_impact_functions ON locations.asset_id=assets_impact_functions.asset_id)
	INNER JOIN impact_functions ON assets_impact_functions.impact_function_id=impact_functions.id)
WHERE locations.asset_id=this_asset_id
	AND decadal_states.scenario_id=this_scen_id
	AND decadal_states.decade=this_decade
	AND impact_functions.risk_factor_id=this_risk_factor_id
	AND decadal_states.hazard_metric_id=impact_functions.hazard_metric_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_hazard_metric_mean_point_by_scenario_decade_riskfactor" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT CAST(AVG(hazard_metric_mean) AS numeric)
FROM (((decadal_states
	INNER JOIN locations ON decadal_states.point_loc_id=locations.id)
	INNER JOIN assets_impact_functions ON locations.asset_id=assets_impact_functions.asset_id)
	INNER JOIN impact_functions ON assets_impact_functions.impact_function_id=impact_functions.id)
WHERE locations.asset_id=this_asset_id
	AND decadal_states.scenario_id=this_scen_id
	AND decadal_states.decade=this_decade
	AND impact_functions.risk_factor_id=this_risk_factor_id
	AND decadal_states.hazard_metric_id=impact_functions.hazard_metric_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_hazard_metric_mean_regional_by_scenario_decade_riskfactor" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT CAST(AVG(hazard_metric_mean) AS numeric)
FROM ((((decadal_states
	INNER JOIN loc_regions ON decadal_states.region_id=loc_regions.region_id)
	INNER JOIN locations ON loc_regions.loc_id=locations.id)
	INNER JOIN assets_impact_functions ON locations.asset_id=assets_impact_functions.asset_id)
	INNER JOIN impact_functions ON assets_impact_functions.impact_function_id=impact_functions.id)
WHERE locations.asset_id=this_asset_id
	AND decadal_states.scenario_id=this_scen_id
	AND decadal_states.decade=this_decade
	AND impact_functions.risk_factor_id=this_risk_factor_id
	AND decadal_states.hazard_metric_id=impact_functions.hazard_metric_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_hazard_metric_name_by_riskfactor" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT COALESCE(asset_hazard_metric_name_by_riskfactor_gridded(this_asset_id, this_risk_factor_id),
			   asset_hazard_metric_name_by_riskfactor_point(this_asset_id, this_risk_factor_id),
			   asset_hazard_metric_name_by_riskfactor_regional(this_asset_id, this_risk_factor_id));
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_hazard_metric_name_by_riskfactor_gridded" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT DISTINCT hazard_metrics.name_etl
FROM (((((decadal_states
	INNER JOIN loc_grid_squares ON decadal_states.grid_square_id=loc_grid_squares.grid_square_id)
	INNER JOIN locations ON loc_grid_squares.loc_id=locations.id)
	INNER JOIN assets_impact_functions ON locations.asset_id=assets_impact_functions.asset_id)
	INNER JOIN impact_functions ON assets_impact_functions.impact_function_id=impact_functions.id)
	INNER JOIN hazard_metrics ON impact_functions.hazard_metric_id=hazard_metrics.id)
WHERE locations.asset_id=this_asset_id
	AND impact_functions.risk_factor_id=this_risk_factor_id
	AND decadal_states.hazard_metric_id=impact_functions.hazard_metric_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_hazard_metric_name_by_riskfactor_point" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT DISTINCT hazard_metrics.name_etl
FROM ((((decadal_states
	INNER JOIN locations ON decadal_states.point_loc_id=locations.id)
	INNER JOIN assets_impact_functions ON locations.asset_id=assets_impact_functions.asset_id)
	INNER JOIN impact_functions ON assets_impact_functions.impact_function_id=impact_functions.id)
	INNER JOIN hazard_metrics ON impact_functions.hazard_metric_id=hazard_metrics.id)
WHERE locations.asset_id=this_asset_id
	AND impact_functions.risk_factor_id=this_risk_factor_id
	AND decadal_states.hazard_metric_id=impact_functions.hazard_metric_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_hazard_metric_name_by_riskfactor_regional" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT DISTINCT hazard_metrics.name_etl
FROM (((((decadal_states
	INNER JOIN loc_regions ON decadal_states.region_id=loc_regions.region_id)
	INNER JOIN locations ON loc_regions.loc_id=locations.id)
	INNER JOIN assets_impact_functions ON locations.asset_id=assets_impact_functions.asset_id)
	INNER JOIN impact_functions ON assets_impact_functions.impact_function_id=impact_functions.id)
	INNER JOIN hazard_metrics ON impact_functions.hazard_metric_id=hazard_metrics.id)
WHERE locations.asset_id=this_asset_id
	AND impact_functions.risk_factor_id=this_risk_factor_id
	AND decadal_states.hazard_metric_id=impact_functions.hazard_metric_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_impact_by_scenario_decade_riskfactor" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT COALESCE(ROUND(CAST(SUM(portion_at_risk) AS numeric),8),0)
FROM ((((risks
		INNER JOIN impact_pathways ON risks.impact_pathway_id=impact_pathways.id)
		INNER JOIN impact_functions ON impact_pathways.impact_function_id=impact_functions.id)
	   	INNER JOIN locations ON risks.location_id=locations.id)
	  	INNER JOIN assets ON locations.asset_id=assets.id)
WHERE assets.id=this_asset_id
	AND risks.scenario_id=this_scen_id
	AND yr=this_decade
	AND impact_functions.risk_factor_id=this_risk_factor_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_impact_to_fmv_by_scenario_decade_riskfactor" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT asset_impact_by_scenario_decade_riskfactor(this_asset_id,this_scen_id,this_decade,this_risk_factor_id)
	* assets.asset_value::numeric AS fmv_impact
FROM assets
WHERE assets.id=this_asset_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_is_complete_hazards" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	complete BOOLEAN;
BEGIN
	-- Are all decadal states for assigned hazards present?
	SELECT asset_is_complete_hazards_point(this_asset_id) INTO complete;
	IF complete IS TRUE THEN
		SELECT asset_is_complete_hazards_gridded(this_asset_id) INTO complete;
	END IF;
	RETURN complete::integer;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_is_complete_hazards_gridded" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	complete BOOLEAN := TRUE;
	total INTEGER;
	loc_rec RECORD;
	hazmet_rec RECORD;
	scen_rec RECORD;
	gs_rec RECORD;
BEGIN
	-- Are all decadal states for assigned gridded hazards present on grid square and not approximated?
	FOR gs_rec IN -- Each grid square 
		SELECT DISTINCT loc_grid_squares.grid_square_id
			FROM (locations
				  INNER JOIN loc_grid_squares ON locations.id=loc_grid_squares.loc_id)
			WHERE locations.asset_id=this_asset_id
	LOOP
		FOR hazmet_rec IN -- Each gridded hazmet assigned
			SELECT DISTINCT hazard_metrics.id
				FROM ((impact_functions
					  INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
					  INNER JOIN hazard_metrics ON impact_functions.hazard_metric_id=hazard_metrics.id)
				WHERE assets_impact_functions.asset_id=this_asset_id AND hazard_metrics.class=1
		LOOP
			FOR scen_rec IN -- Each scenario
				SELECT id FROM scenarios
			LOOP
				SELECT COUNT(decade) INTO total
					FROM decadal_states
					WHERE grid_square_id=gs_rec.grid_square_id AND hazard_metric_id=hazmet_rec.id AND scenario_id=scen_rec.id AND approximated=FALSE;
				IF total != 10 THEN complete=FALSE; END IF;
			END LOOP;
		END LOOP;
	END LOOP;
	RETURN complete::integer;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_is_complete_hazards_point" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	complete BOOLEAN := TRUE;
	total INTEGER;
	loc_rec RECORD;
	hazmet_rec RECORD;
	scen_rec RECORD;
	gs_rec RECORD;
BEGIN
	-- Are all decadal states for assigned point hazards present?
	FOR loc_rec IN -- Each location
		SELECT id FROM locations WHERE asset_id=this_asset_id
	LOOP
		FOR hazmet_rec IN -- Each point hazmet assigned
			SELECT DISTINCT hazard_metrics.id
				FROM ((impact_functions
					  INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
					  INNER JOIN hazard_metrics ON impact_functions.hazard_metric_id=hazard_metrics.id)
				WHERE assets_impact_functions.asset_id=this_asset_id AND hazard_metrics.class=2
		LOOP
			FOR scen_rec IN -- Each scenario
				SELECT id FROM scenarios
			LOOP
				SELECT COUNT(decade) INTO total
					FROM decadal_states
					WHERE point_loc_id=loc_rec.id AND hazard_metric_id=hazmet_rec.id AND scenario_id=scen_rec.id;
				IF total != 10 THEN complete=FALSE; END IF;
			END LOOP;
		END LOOP;
	END LOOP;
	RETURN complete::integer;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_is_complete_risks" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	complete BOOLEAN := TRUE;
	total INTEGER;
	loc_rec RECORD;
	scen_rec RECORD;
	pw_rec RECORD;
BEGIN
	-- Are all risks present for 21st century?
	FOR loc_rec IN -- Each location
		SELECT id FROM locations WHERE asset_id=this_asset_id
	LOOP
		FOR pw_rec IN -- Each impact pathway on impact functions assigned to this asset
			SELECT DISTINCT impact_pathways.id
				FROM ((assets_impact_functions
					 INNER JOIN impact_functions ON assets_impact_functions.impact_function_id=impact_functions.id)
					 INNER JOIN impact_pathways ON impact_functions.id=impact_pathways.impact_function_id)
				WHERE assets_impact_functions.asset_id=this_asset_id
		LOOP
			FOR scen_rec IN -- Each scenario
				SELECT id FROM scenarios
			LOOP
				SELECT COUNT(yr) INTO total
					FROM risks WHERE location_id=loc_rec.id AND impact_pathway_id=pw_rec.id AND scenario_id=scen_rec.id;
				IF total != 9 THEN
					complete=FALSE;
					-- RAISE NOTICE 'Incomplete: yrs %, loc %, pw %, scen %', total, loc_rec.id, pw_rec.id, scen_rec.id;
				END IF;
			END LOOP;
		END LOOP;
	END LOOP;
	-- TODO: Add check for all flags on locations
	RETURN complete::integer;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_qty_locations" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT COUNT(*)::integer FROM locations WHERE asset_id=this_entity_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_risks_riskfactor_decade" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT COALESCE(ROUND(CAST(SUM(portion_at_risk) AS numeric),8),0)
FROM (((((risks
		INNER JOIN impact_pathways ON risks.impact_pathway_id=impact_pathways.id)
		INNER JOIN impact_functions ON impact_pathways.impact_function_id=impact_functions.id)
	   	INNER JOIN locations ON risks.location_id=locations.id)
	  	INNER JOIN assets ON locations.asset_id=assets.id)
	 	INNER JOIN scenarios ON risks.scenario_id=scenarios.id)
WHERE assets.id=this_asset_id
	AND scenarios.name_etl=this_scen
	AND yr=this_decade
	AND impact_functions.risk_factor_id=this_risk_factor_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_risks_total_decade" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT COALESCE(ROUND(CAST(SUM(portion_at_risk) AS numeric),8),0)
FROM ((((risks
		INNER JOIN impact_pathways ON risks.impact_pathway_id=impact_pathways.id)
		INNER JOIN impact_functions ON impact_pathways.impact_function_id=impact_functions.id)
	   	INNER JOIN locations ON risks.location_id=locations.id)
	  	INNER JOIN assets ON locations.asset_id=assets.id)
WHERE assets.id=this_asset_id
	AND risks.scenario_id=this_scen_id
	AND yr=this_decade;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_risks_total_decade_by_risk_analysis" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT COALESCE(ROUND(CAST(SUM(portion_at_risk) AS numeric),8),0)
FROM (((((risks
		INNER JOIN impact_pathways ON risks.impact_pathway_id=impact_pathways.id)
		INNER JOIN impact_functions ON impact_pathways.impact_function_id=impact_functions.id)
	   	INNER JOIN locations ON risks.location_id=locations.id)
	  	INNER JOIN assets ON locations.asset_id=assets.id)
	 	INNER JOIN scenarios ON risks.scenario_id=scenarios.id)
WHERE assets.id=this_asset_id
	AND scenarios.name_etl=this_scen
	AND yr=this_decade
	AND impact_functions.risk_factor_id IN (
	WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id
      )
      SELECT risk_factors.id
      FROM risk_factors 
      JOIN rf_category_risk_factors
      ON risk_factors.id = rf_category_risk_factors.risk_factor_id
      LEFT JOIN rf_categories
      ON rf_category_risk_factors.rf_category_id = rf_categories.id
      JOIN risk_factor_tree
      ON rf_categories.parent_id = risk_factor_tree.id WHERE risk_factor_tree.name LIKE(this_risk_analysis) ORDER BY risk_factors.id);
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="asset_tags_combinations" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
WITH RECURSIVE t(i) AS (SELECT DISTINCT tags.name::text AS name
						FROM ((assets INNER JOIN assets_tags ON assets.id=assets_tags.asset_id)
							  INNER JOIN tags ON assets_tags.tag_id=tags.id)
						WHERE assets.id=this_asset_id AND assets.is_active = 1 ORDER BY name ASC), cte AS (
							SELECT i AS tags_combo, i, 1 AS ct
							FROM t UNION
							SELECT cte.tags_combo || ';' || t.i, t.i, ct + 1
							FROM cte JOIN t ON t.i > cte.i
) SELECT '' AS ct UNION SELECT tags_combo FROM cte ORDER BY ct;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="auditing_timestamp_update" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="breakpoints_interpolate" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	y numeric := 0;
	x1 numeric;
	y1 numeric;
	x2 numeric;
	y2 numeric;
	x_arry numeric[];
	y_arry numeric[];
	arrylen numeric;
	slope numeric;
	intercept numeric;
BEGIN
	x_arry := regexp_split_to_array(xlist, ';');
	y_arry := regexp_split_to_array(ylist, ';');
	arrylen := array_length( x_arry, 1 );
	FOR i IN 1 .. arrylen LOOP
		x1 := x_arry[i];
		y1 := y_arry[i];
		x2 := x_arry[i+1];
		y2 := y_arry[i+1];
		IF (x < x1 AND x1 < x2) THEN -- Ascending and out of range
			y := y1; EXIT;
		ELSEIF (x > x1 AND x1 > x2) THEN -- Desc and out of range
			y := y1; EXIT;
		ELSEIF (x1 = x) THEN
			y := y1; EXIT;
		ELSEIF (x1 < x AND x2 > x) THEN
			slope := ( (y2-y1) / (x2-x1) );
			intercept := ( y1 - ( slope * x1 ) );
			y := slope * x + intercept; EXIT;
		ELSEIF (x2 < x AND x1 > x ) THEN
			slope := ( (y1-y2) / (x1-x2) );
			intercept := ( y2 - ( slope * x2 ) );
			y := slope * x + intercept; EXIT;
		ELSE y := y1;
		END IF;
	END LOOP;
	RETURN ROUND(y, 10);
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citext" returnType="citext" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="INTERNAL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citext_cmp" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citext_eq" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citext_ge" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citext_gt" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citext_hash" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citext_hash_extended" returnType="bigint" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citext_larger" returnType="citext" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citext_le" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citext_lt" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citext_ne" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citext_pattern_cmp" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citext_pattern_ge" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citext_pattern_gt" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citext_pattern_le" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citext_pattern_lt" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citext_smaller" returnType="citext" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citextin" returnType="citext" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="INTERNAL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="citextout" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="INTERNAL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="citextrecv" returnType="citext" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="INTERNAL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="citextsend" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="INTERNAL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="create_dblink_extension" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
                persist_dblink_extension boolean;
        BEGIN
            SELECT EXISTS(SELECT 1 FROM pg_extension WHERE extname='dblink')::boolean::boolean INTO persist_dblink_extension;
            IF persist_dblink_extension = FALSE
            THEN
                CREATE EXTENSION IF NOT EXISTS dblink;
            END IF;
            RETURN persist_dblink_extension;
        END
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="create_ref_id_trigger" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
  customer_id integer;
  new_ref_id integer;
  slug text;
  slug_uuid text;
BEGIN
  -- check for null or empty string values
  IF NEW.ref_id IS NULL THEN
    -- retrieve relevant customer ID needed for ref_id table. TODO: determine Investments approach
    CASE TG_TABLE_NAME
    WHEN 'groups' THEN
      customer_id = (NEW.customer_id);
      slug = 'GRP';
    WHEN 'folders' THEN
      customer_id = (SELECT groups.customer_id from groups WHERE groups.id = NEW.group_id);
      slug = 'FLDR';
    WHEN 'assets' THEN
      -- limit 1 here in case of shared Listed Equities entries
      customer_id = (SELECT groups.customer_id from groups INNER JOIN folders ON folders.group_id = groups.id INNER JOIN folders_investments ON folders.id = folders_investments.folder_id WHERE folders_investments.investment_id = NEW.investment_id LIMIT 1);
      slug = 'ASSET';
    WHEN 'locations' THEN
      -- limit 1 here in case of shared Listed Equities entries
      customer_id = (SELECT groups.customer_id from groups INNER JOIN folders ON folders.group_id = groups.id INNER JOIN folders_investments ON folders.id = folders_investments.folder_id INNER JOIN assets ON folders_investments.investment_id = assets.investment_id WHERE assets.id = NEW.asset_id LIMIT 1);
      slug = 'LOC';
    ELSE
      RAISE EXCEPTION 'Unsupported TABLE: %. Current table currently not supported for auto-create of ref_id.', TG_TABLE_NAME;
    END CASE;
    -- generate slug prefixed uuid
    slug_uuid := create_slug_uuid(slug);
    EXECUTE format('INSERT INTO ref_id (customer_id, ref_name, ref_type, is_active) VALUES ($1, $2, $3, DEFAULT) RETURNING id;') USING 
    customer_id, slug_uuid, RTRIM(TG_TABLE_NAME, 's')::ref_enum_type INTO new_ref_id;
    NEW.ref_id = new_ref_id;
  END IF;
  RETURN NEW;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="create_slug_uuid" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
  slug_uuid character varying;
BEGIN
  -- returns a generated uuid even if a slug is not provided
  slug_uuid := uuid_generate_v4();
  -- invoke uuid FUNCTION with slug prepended 
  IF slug != '' THEN
    slug_uuid := CONCAT(slug,'-', slug_uuid);
  END IF;
  -- return generated ref-id
  RETURN slug_uuid;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="create_subscription" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
                     persist_dblink_extension boolean;
                BEGIN
                    persist_dblink_extension := create_dblink_extension();
                    PERFORM dblink_connect(format('dbname=%s', db_name));
                    PERFORM dblink_exec(format('CREATE SUBSCRIPTION %s CONNECTION ''host=%s port=%s password=%s user=%s dbname=%s sslmode=require'' PUBLICATION %s',subscription_name, host_ip, portNum, password, username, db_name, publisher_name));
                    PERFORM dblink_disconnect();
                    IF persist_dblink_extension = FALSE
                    THEN
                        DROP EXTENSION IF EXISTS dblink;
                    END IF;
                    RETURN 'ok';
                END
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_asset_type_impact_rpt_by_category_scenario_decade" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_scen_id integer;
	this_fmv numeric;
BEGIN
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
SELECT SUM(assets.asset_value) INTO this_fmv
FROM assets
WHERE id IN (SELECT DISTINCT assets.id
			FROM ((((((((risk_factors
			INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
			INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
			INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
			INNER JOIN investments ON assets.investment_id=investments.id)
			INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
			INNER JOIN folders ON folders_investments.folder_id=folders.id)
			INNER JOIN groups ON folders.group_id=groups.id)
			INNER JOIN customers ON groups.customer_id=customers.id)
			WHERE customers.name=this_cust_name);
RETURN QUERY
WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id)
SELECT asset_types.name, ROUND(this_fmv,3),
	ROUND(SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)),3) AS fmv_impact,
	ROUND((100 * SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)) / this_fmv),3) AS fmv_pct
FROM (((((((((risk_factors
	INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
	INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
	INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
	INNER JOIN asset_types ON assets.asset_type_id=asset_types.id)
	INNER JOIN investments ON assets.investment_id=investments.id)
	INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
	INNER JOIN folders ON folders_investments.folder_id=folders.id)
	INNER JOIN groups ON folders.group_id=groups.id)
	INNER JOIN customers ON groups.customer_id=customers.id)
WHERE customers.name=this_cust_name
	AND risk_factors.id IN (SELECT DISTINCT rf_category_risk_factors.risk_factor_id
							FROM ((rf_category_risk_factors
								LEFT JOIN rf_categories ON rf_category_risk_factors.rf_category_id=rf_categories.id)
								INNER JOIN risk_factor_tree ON rf_categories.parent_id=risk_factor_tree.id)
							WHERE risk_factor_tree.name=this_category)
GROUP BY asset_types.name
ORDER BY fmv_impact DESC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_assets_ext_rpt_by_riskfactor_and_scenario" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_cust_id integer;
	this_rf_id integer;
	this_scen_id integer;
BEGIN
SELECT customers.id INTO this_cust_id FROM customers WHERE name=this_cust_name;
SELECT risk_factors.id INTO this_rf_id FROM risk_factors WHERE name=this_riskfactor_name;
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
RETURN QUERY
SELECT assets.name AS asset_name,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2020,this_rf_id) * 100,3)::double precision AS pct_at_risk_2020,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2030,this_rf_id) * 100,3)::double precision AS pct_at_risk_2030,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2040,this_rf_id) * 100,3)::double precision AS pct_at_risk_2040,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2050,this_rf_id) * 100,3)::double precision AS pct_at_risk_2050,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2060,this_rf_id) * 100,3)::double precision AS pct_at_risk_2060,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2070,this_rf_id) * 100,3)::double precision AS pct_at_risk_2070,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2080,this_rf_id) * 100,3)::double precision AS pct_at_risk_2080,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2090,this_rf_id) * 100,3)::double precision AS pct_at_risk_2090,
	assets.asset_value,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2020,this_rf_id), 6)::double precision AS val_at_risk_2020,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2030,this_rf_id), 6)::double precision AS val_at_risk_2030,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2040,this_rf_id), 6)::double precision AS val_at_risk_2040,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2050,this_rf_id), 6)::double precision AS val_at_risk_2050,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2060,this_rf_id), 6)::double precision AS val_at_risk_2060,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2070,this_rf_id), 6)::double precision AS val_at_risk_2070,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2080,this_rf_id), 6)::double precision AS val_at_risk_2080,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2090,this_rf_id), 6)::double precision AS val_at_risk_2090,
	asset_hazard_metric_name_by_riskfactor(assets.id,this_rf_id),
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,0,this_rf_id) AS hazmet_mean_hist,
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,2020,this_rf_id) AS hazmet_mean_2020,
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,2030,this_rf_id) AS hazmet_mean_2030,
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,2040,this_rf_id) AS hazmet_mean_2040,
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,2050,this_rf_id) AS hazmet_mean_2050,
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,2060,this_rf_id) AS hazmet_mean_2060,
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,2070,this_rf_id) AS hazmet_mean_2070,
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,2080,this_rf_id) AS hazmet_mean_2080,
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,2090,this_rf_id) AS hazmet_mean_2090,
	assets.id, investments.name, investments.id, folders.name, folders.id, groups.name, groups.id,
	(SELECT admin_area_level0 FROM locations WHERE locations.asset_id=assets.id LIMIT 1) AS country,
	(SELECT string_agg(tags.name::text, ';') FROM (assets_tags INNER JOIN tags ON assets_tags.tag_id=tags.id)
	 	WHERE assets_tags.asset_id=assets.id)::character varying AS asset_tags
FROM ((((assets
		INNER JOIN investments ON assets.investment_id=investments.id)
		INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
		INNER JOIN folders ON folders_investments.folder_id=folders.id)
		INNER JOIN groups ON folders.group_id=groups.id)
WHERE assets.id IN (
					SELECT DISTINCT assets.id
					FROM (((assets
						INNER JOIN folders_investments ON assets.investment_id=folders_investments.investment_id)
						INNER JOIN folders ON folders_investments.folder_id=folders.id)
						INNER JOIN groups ON folders.group_id=groups.id)
					WHERE groups.customer_id=this_cust_id
)
ORDER BY assets.name;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_assets_rpt" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_cust_id integer;
	this_scen_id integer;
BEGIN
SELECT customers.id INTO this_cust_id FROM customers WHERE name=this_cust_name;
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
RETURN QUERY
SELECT * FROM cust_assets_rpt(this_cust_id,this_scen_id,this_riskfactor_id);
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_assets_rpt_by_riskfactor_and_scenario" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_cust_id integer;
	this_rf_id integer;
	this_scen_id integer;
BEGIN
SELECT customers.id INTO this_cust_id FROM customers WHERE name=this_cust_name;
SELECT risk_factors.id INTO this_rf_id FROM risk_factors WHERE name=this_riskfactor_name;
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
RETURN QUERY
SELECT assets.name AS asset_name,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2020,this_rf_id) * 100, 3)::double precision AS pct_at_risk_2020,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2030,this_rf_id) * 100, 3)::double precision AS pct_at_risk_2030,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2040,this_rf_id) * 100, 3)::double precision AS pct_at_risk_2040,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2050,this_rf_id) * 100, 3)::double precision AS pct_at_risk_2050,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2060,this_rf_id) * 100, 3)::double precision AS pct_at_risk_2060,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2070,this_rf_id) * 100, 3)::double precision AS pct_at_risk_2070,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2080,this_rf_id) * 100, 3)::double precision AS pct_at_risk_2080,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2090,this_rf_id) * 100, 3)::double precision AS pct_at_risk_2090,
	assets.asset_value,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2020,this_rf_id), 6)::double precision AS val_at_risk_2020,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2030,this_rf_id), 6)::double precision AS val_at_risk_2030,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2040,this_rf_id), 6)::double precision AS val_at_risk_2040,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2050,this_rf_id), 6)::double precision AS val_at_risk_2050,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2060,this_rf_id), 6)::double precision AS val_at_risk_2060,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2070,this_rf_id), 6)::double precision AS val_at_risk_2070,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2080,this_rf_id), 6)::double precision AS val_at_risk_2080,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2090,this_rf_id), 6)::double precision AS val_at_risk_2090,
	investments.name, folders.name, groups.name, (SELECT admin_area_level0 FROM locations WHERE locations.asset_id=assets.id LIMIT 1) AS country,
	(SELECT string_agg(tags.name::text, ';') FROM (assets_tags INNER JOIN tags ON assets_tags.tag_id=tags.id)
	 	WHERE assets_tags.asset_id=assets.id)::character varying AS asset_tags
FROM ((((assets
		INNER JOIN investments ON assets.investment_id=investments.id)
		INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
		INNER JOIN folders ON folders_investments.folder_id=folders.id)
		INNER JOIN groups ON folders.group_id=groups.id)
WHERE assets.id IN (
					SELECT DISTINCT assets.id
					FROM (((assets
						INNER JOIN folders_investments ON assets.investment_id=folders_investments.investment_id)
						INNER JOIN folders ON folders_investments.folder_id=folders.id)
						INNER JOIN groups ON folders.group_id=groups.id)
					WHERE groups.customer_id=this_cust_id
)
ORDER BY assets.name;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_folder_assets_ext_rpt_by_riskfactor_and_scenario" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_cust_id integer;
	this_group_id integer;
	this_folder_id integer;
	this_rf_id integer;
	this_scen_id integer;
BEGIN
SELECT customers.id INTO this_cust_id FROM customers WHERE name=this_cust_name;
SELECT groups.id INTO this_group_id FROM groups WHERE name=this_group_name AND customer_id=this_cust_id;
SELECT folders.id INTO this_folder_id FROM folders WHERE name=this_folder_name AND folders.group_id=this_group_id;
SELECT risk_factors.id INTO this_rf_id FROM risk_factors WHERE name=this_riskfactor_name;
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
RETURN QUERY
SELECT assets.name AS asset_name,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2020,this_rf_id) * 100,3)::double precision AS pct_at_risk_2020,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2030,this_rf_id) * 100,3)::double precision AS pct_at_risk_2030,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2040,this_rf_id) * 100,3)::double precision AS pct_at_risk_2040,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2050,this_rf_id) * 100,3)::double precision AS pct_at_risk_2050,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2060,this_rf_id) * 100,3)::double precision AS pct_at_risk_2060,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2070,this_rf_id) * 100,3)::double precision AS pct_at_risk_2070,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2080,this_rf_id) * 100,3)::double precision AS pct_at_risk_2080,
	ROUND(asset_impact_by_scenario_decade_riskfactor(assets.id,this_scen_id,2090,this_rf_id) * 100,3)::double precision AS pct_at_risk_2090,
	assets.asset_value,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2020,this_rf_id), 6)::double precision AS val_at_risk_2020,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2030,this_rf_id), 6)::double precision AS val_at_risk_2030,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2040,this_rf_id), 6)::double precision AS val_at_risk_2040,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2050,this_rf_id), 6)::double precision AS val_at_risk_2050,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2060,this_rf_id), 6)::double precision AS val_at_risk_2060,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2070,this_rf_id), 6)::double precision AS val_at_risk_2070,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2080,this_rf_id), 6)::double precision AS val_at_risk_2080,
	ROUND(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,2090,this_rf_id), 6)::double precision AS val_at_risk_2090,
	asset_hazard_metric_name_by_riskfactor(assets.id,this_rf_id),
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,0,this_rf_id) AS hazmet_mean_hist,
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,2020,this_rf_id) AS hazmet_mean_2020,
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,2030,this_rf_id) AS hazmet_mean_2030,
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,2040,this_rf_id) AS hazmet_mean_2040,
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,2050,this_rf_id) AS hazmet_mean_2050,
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,2060,this_rf_id) AS hazmet_mean_2060,
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,2070,this_rf_id) AS hazmet_mean_2070,
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,2080,this_rf_id) AS hazmet_mean_2080,
	asset_hazard_metric_mean_by_scenario_decade_riskfactor(assets.id,this_scen_id,2090,this_rf_id) AS hazmet_mean_2090,
	assets.id, investments.name, investments.id, folders.name, folders.id, groups.name, groups.id,
	(SELECT admin_area_level0 FROM locations WHERE locations.asset_id=assets.id LIMIT 1) AS country,
	(SELECT string_agg(tags.name::text, ';') FROM (assets_tags INNER JOIN tags ON assets_tags.tag_id=tags.id)
	 	WHERE assets_tags.asset_id=assets.id)::character varying AS asset_tags
FROM ((((assets
		INNER JOIN investments ON assets.investment_id=investments.id)
		INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
		INNER JOIN folders ON folders_investments.folder_id=folders.id)
		INNER JOIN groups ON folders.group_id=groups.id)
WHERE assets.id IN
		(SELECT DISTINCT assets.id
			FROM (((assets
				INNER JOIN folders_investments ON assets.investment_id=folders_investments.investment_id)
				INNER JOIN folders ON folders_investments.folder_id=folders.id)
				INNER JOIN groups ON folders.group_id=groups.id)
			WHERE groups.customer_id=this_cust_id AND groups.id=this_group_id AND folders.id=this_folder_id)
ORDER BY assets.name;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_folder_impact_timeseries_by_category_scenario" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_scen_id integer;
BEGIN
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
RETURN QUERY
WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id)
SELECT decades.decade,
	ROUND(SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,decades.decade,risk_factors.id)),3) AS fmv_impact
FROM (((((((((risk_factors
	INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
	INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
	INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
	INNER JOIN investments ON assets.investment_id=investments.id)
	INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
	INNER JOIN folders ON folders_investments.folder_id=folders.id)
	INNER JOIN groups ON folders.group_id=groups.id)
	INNER JOIN customers ON groups.customer_id=customers.id)
	CROSS JOIN (VALUES (2010),(2020),(2030),(2040),(2050),(2060),(2070),(2080),(2090)) AS decades (decade))
WHERE customers.name=this_cust_name
	AND groups.name=this_group_name
	AND folders.name=this_folder_name
	AND risk_factors.id IN (SELECT DISTINCT rf_category_risk_factors.risk_factor_id
							FROM ((rf_category_risk_factors
								LEFT JOIN rf_categories ON rf_category_risk_factors.rf_category_id=rf_categories.id)
								INNER JOIN risk_factor_tree ON rf_categories.parent_id=risk_factor_tree.id)
							WHERE risk_factor_tree.name=this_category)
GROUP BY decades.decade
ORDER BY decades.decade ASC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_folder_riskfactor_rpt_by_category_scenario_decade" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_scen_id integer;
	this_fmv numeric;
BEGIN
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
SELECT SUM(assets.asset_value) INTO this_fmv
FROM assets
WHERE id IN (SELECT DISTINCT assets.id
			FROM ((((((((risk_factors
			INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
			INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
			INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
			INNER JOIN investments ON assets.investment_id=investments.id)
			INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
			INNER JOIN folders ON folders_investments.folder_id=folders.id)
			INNER JOIN groups ON folders.group_id=groups.id)
			INNER JOIN customers ON groups.customer_id=customers.id)
			WHERE customers.name=this_cust_name
				AND groups.name=this_group_name
				AND folders.name=this_folder_name);
RETURN QUERY
WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id)
SELECT risk_factors.name, ROUND(this_fmv,3),
	ROUND(SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)),3) AS fmv_impact,
	ROUND((100 * SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)) / this_fmv),3) AS fmv_pct
FROM ((((((((risk_factors
	INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
	INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
	INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
	INNER JOIN investments ON assets.investment_id=investments.id)
	INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
	INNER JOIN folders ON folders_investments.folder_id=folders.id)
	INNER JOIN groups ON folders.group_id=groups.id)
	INNER JOIN customers ON groups.customer_id=customers.id)
WHERE customers.name=this_cust_name
	AND groups.name=this_group_name
	AND folders.name=this_folder_name
	AND risk_factors.id IN (SELECT DISTINCT rf_category_risk_factors.risk_factor_id
							FROM ((rf_category_risk_factors
								LEFT JOIN rf_categories ON rf_category_risk_factors.rf_category_id=rf_categories.id)
								INNER JOIN risk_factor_tree ON rf_categories.parent_id=risk_factor_tree.id)
							WHERE risk_factor_tree.name=this_category)
GROUP BY risk_factors.name
ORDER BY fmv_impact DESC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_group_asset_type_impact_rpt_by_category_scenario_decade" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_scen_id integer;
	this_fmv numeric;
BEGIN
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
SELECT SUM(assets.asset_value) INTO this_fmv
FROM assets
WHERE id IN (SELECT DISTINCT assets.id
			FROM ((((((((risk_factors
			INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
			INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
			INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
			INNER JOIN investments ON assets.investment_id=investments.id)
			INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
			INNER JOIN folders ON folders_investments.folder_id=folders.id)
			INNER JOIN groups ON folders.group_id=groups.id)
			INNER JOIN customers ON groups.customer_id=customers.id)
			WHERE customers.name=this_cust_name
				AND groups.name=this_group_name);
RETURN QUERY
WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id)
SELECT asset_types.name, ROUND(this_fmv,3),
	ROUND(SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)),3) AS fmv_impact,
	ROUND((100 * SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)) / this_fmv),3) AS fmv_pct
FROM (((((((((risk_factors
	INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
	INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
	INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
	INNER JOIN asset_types ON assets.asset_type_id=asset_types.id)
	INNER JOIN investments ON assets.investment_id=investments.id)
	INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
	INNER JOIN folders ON folders_investments.folder_id=folders.id)
	INNER JOIN groups ON folders.group_id=groups.id)
	INNER JOIN customers ON groups.customer_id=customers.id)
WHERE customers.name=this_cust_name
	AND groups.name=this_group_name
	AND risk_factors.id IN (SELECT DISTINCT rf_category_risk_factors.risk_factor_id
							FROM ((rf_category_risk_factors
								LEFT JOIN rf_categories ON rf_category_risk_factors.rf_category_id=rf_categories.id)
								INNER JOIN risk_factor_tree ON rf_categories.parent_id=risk_factor_tree.id)
							WHERE risk_factor_tree.name=this_category)
GROUP BY asset_types.name
ORDER BY fmv_impact DESC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_group_impact_rpt_by_scenario" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_cust_id integer;
	this_group_id integer;
	this_scen_id integer;
BEGIN
SELECT customers.id INTO this_cust_id FROM customers WHERE customers.name=this_cust_name;
SELECT groups.id INTO this_group_id FROM groups WHERE groups.name=this_group_name AND groups.customer_id=this_cust_id;
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
RETURN QUERY
SELECT folders.name,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2020,'Physical Risk')
	+ folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2020,'Transition Risk'), 6)
		AS phys_trans_imp_m_usd_2020,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2030,'Physical Risk')
	+ folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2030,'Transition Risk'), 6)
		AS phys_trans_imp_m_usd_2030,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2040,'Physical Risk')
	+ folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2040,'Transition Risk'), 6)
		AS phys_trans_imp_m_usd_2040,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2050,'Physical Risk')
	+ folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2050,'Transition Risk'), 6)
		AS phys_trans_imp_m_usd_2050,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2060,'Physical Risk')
	+ folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2060,'Transition Risk'), 6)
		AS phys_trans_imp_m_usd_2060,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2070,'Physical Risk')
	+ folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2070,'Transition Risk'), 6)
		AS phys_trans_imp_m_usd_2070,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2080,'Physical Risk')
	+ folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2080,'Transition Risk'), 6)
		AS phys_trans_imp_m_usd_2080,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2090,'Physical Risk')
	+ folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2090,'Transition Risk'), 6)
		AS phys_trans_imp_m_usd_2090,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2020,'Opportunity'), 6)
		AS oppor_imp_m_usd_2020,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2030,'Opportunity'), 6)
		AS oppor_imp_m_usd_2030,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2040,'Opportunity'), 6)
		AS oppor_imp_m_usd_2040,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2050,'Opportunity'), 6)
		AS oppor_imp_m_usd_2050,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2060,'Opportunity'), 6)
		AS oppor_imp_m_usd_2060,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2070,'Opportunity'), 6)
		AS oppor_imp_m_usd_2070,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2080,'Opportunity'), 6)
		AS oppor_imp_m_usd_2080,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,2090,'Opportunity'), 6)
		AS oppor_imp_m_usd_2090,
	ROUND(folder_fmv(folders.id), 6) AS fmv_m_usd,
	ROUND(group_fmv(folders.group_id), 6) AS group_fmv_m_usd
FROM folders
WHERE folders.group_id=this_group_id
ORDER BY folders.name ASC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_group_impact_rpt_by_scenario_decade" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_cust_id integer;
	this_group_id integer;
	this_scen_id integer;
BEGIN
SELECT customers.id INTO this_cust_id FROM customers WHERE customers.name=this_cust_name;
SELECT groups.id INTO this_group_id FROM groups WHERE groups.name=this_group_name AND groups.customer_id=this_cust_id;
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
RETURN QUERY
SELECT folders.name,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,this_decade,'Physical Risk')
	+ folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,this_decade,'Transition Risk'), 6)
		AS phys_trans_imp_m_usd,
	ROUND(folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,this_decade,'Opportunity'), 6)
		AS oppor_imp_m_usd,
	ROUND(100 * (folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,this_decade,'Physical Risk')
	+ folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,this_decade,'Transition Risk'))
	/ group_fmv(this_group_id), 4) AS phys_trans_imp_pct_to_group,
	ROUND(100 * (folder_impact_to_fmv_by_scenario_decade_category(folders.id,this_scen_id,this_decade,'Opportunity'))
	/ group_fmv(this_group_id), 4) AS oppor_imp_pct_to_group
FROM folders
WHERE folders.group_id=this_group_id
ORDER BY folders.name ASC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_group_impact_timeseries_by_category_scenario" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_scen_id integer;
BEGIN
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
RETURN QUERY
WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id)
SELECT decades.decade,
	ROUND(SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,decades.decade,risk_factors.id)),3) AS fmv_impact
FROM (((((((((risk_factors
	INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
	INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
	INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
	INNER JOIN investments ON assets.investment_id=investments.id)
	INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
	INNER JOIN folders ON folders_investments.folder_id=folders.id)
	INNER JOIN groups ON folders.group_id=groups.id)
	INNER JOIN customers ON groups.customer_id=customers.id)
	CROSS JOIN (VALUES (2010),(2020),(2030),(2040),(2050),(2060),(2070),(2080),(2090)) AS decades (decade))
WHERE customers.name=this_cust_name
	AND groups.name=this_group_name
	AND risk_factors.id IN (SELECT DISTINCT rf_category_risk_factors.risk_factor_id
							FROM ((rf_category_risk_factors
								LEFT JOIN rf_categories ON rf_category_risk_factors.rf_category_id=rf_categories.id)
								INNER JOIN risk_factor_tree ON rf_categories.parent_id=risk_factor_tree.id)
							WHERE risk_factor_tree.name=this_category)
GROUP BY decades.decade
ORDER BY decades.decade ASC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_group_nation_impact_rpt_by_category_scenario_decade" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_scen_id integer;
	this_fmv numeric;
BEGIN
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
SELECT SUM(assets.asset_value) INTO this_fmv
FROM assets
WHERE id IN (SELECT DISTINCT assets.id
			FROM ((((((((risk_factors
			INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
			INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
			INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
			INNER JOIN investments ON assets.investment_id=investments.id)
			INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
			INNER JOIN folders ON folders_investments.folder_id=folders.id)
			INNER JOIN groups ON folders.group_id=groups.id)
			INNER JOIN customers ON groups.customer_id=customers.id)
			WHERE customers.name=this_cust_name
				AND groups.name=this_group_name);
RETURN QUERY
WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id)
SELECT locations.admin_area_level0, ROUND(this_fmv,3),
	ROUND(SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)),3) AS fmv_impact,
	ROUND((100 * SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)) / this_fmv),3) AS fmv_pct
FROM ((((((((((risk_factors
	INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
	INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
	INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
	INNER JOIN locations ON assets.id=locations.asset_id)
	INNER JOIN asset_types ON assets.asset_type_id=asset_types.id)
	INNER JOIN investments ON assets.investment_id=investments.id)
	INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
	INNER JOIN folders ON folders_investments.folder_id=folders.id)
	INNER JOIN groups ON folders.group_id=groups.id)
	INNER JOIN customers ON groups.customer_id=customers.id)
WHERE customers.name=this_cust_name
	AND groups.name=this_group_name
	AND risk_factors.id IN (SELECT DISTINCT rf_category_risk_factors.risk_factor_id
							FROM ((rf_category_risk_factors
								LEFT JOIN rf_categories ON rf_category_risk_factors.rf_category_id=rf_categories.id)
								INNER JOIN risk_factor_tree ON rf_categories.parent_id=risk_factor_tree.id)
							WHERE risk_factor_tree.name=this_category)
GROUP BY locations.admin_area_level0
ORDER BY fmv_impact DESC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_group_riskfactor_rpt_by_category_scenario_decade" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_scen_id integer;
	this_fmv numeric;
BEGIN
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
SELECT SUM(assets.asset_value) INTO this_fmv
FROM assets
WHERE id IN (SELECT DISTINCT assets.id
			FROM ((((((((risk_factors
			INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
			INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
			INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
			INNER JOIN investments ON assets.investment_id=investments.id)
			INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
			INNER JOIN folders ON folders_investments.folder_id=folders.id)
			INNER JOIN groups ON folders.group_id=groups.id)
			INNER JOIN customers ON groups.customer_id=customers.id)
			WHERE customers.name=this_cust_name
				AND groups.name=this_group_name);
RETURN QUERY
WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id)
SELECT risk_factors.name, ROUND(this_fmv,3),
	ROUND(SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)),3) AS fmv_impact,
	ROUND((100 * SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)) / this_fmv),3) AS fmv_pct
FROM ((((((((risk_factors
	INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
	INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
	INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
	INNER JOIN investments ON assets.investment_id=investments.id)
	INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
	INNER JOIN folders ON folders_investments.folder_id=folders.id)
	INNER JOIN groups ON folders.group_id=groups.id)
	INNER JOIN customers ON groups.customer_id=customers.id)
WHERE customers.name=this_cust_name
	AND groups.name=this_group_name
	AND risk_factors.id IN (SELECT DISTINCT rf_category_risk_factors.risk_factor_id
							FROM ((rf_category_risk_factors
								LEFT JOIN rf_categories ON rf_category_risk_factors.rf_category_id=rf_categories.id)
								INNER JOIN risk_factor_tree ON rf_categories.parent_id=risk_factor_tree.id)
							WHERE risk_factor_tree.name=this_category)
GROUP BY risk_factors.name
ORDER BY fmv_impact DESC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_group_riskfactor_rpt_by_category_scenario_decade_nation" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_scen_id integer;
	this_fmv numeric;
BEGIN
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
SELECT SUM(assets.asset_value) INTO this_fmv
FROM assets
WHERE id IN (SELECT DISTINCT assets.id
			FROM (((((((((risk_factors
			INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
			INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
			INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
			INNER JOIN locations ON assets.id=locations.asset_id)
			INNER JOIN investments ON assets.investment_id=investments.id)
			INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
			INNER JOIN folders ON folders_investments.folder_id=folders.id)
			INNER JOIN groups ON folders.group_id=groups.id)
			INNER JOIN customers ON groups.customer_id=customers.id)
			WHERE customers.name=this_cust_name
			 	AND groups.name=this_group_name
				AND locations.admin_area_level0=this_nation);
RETURN QUERY
WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id)
SELECT risk_factors.name, ROUND(this_fmv,3),
	ROUND(SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)),3) AS fmv_impact,
	ROUND((100 * SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)) / this_fmv),3) AS fmv_pct
FROM (((((((((risk_factors
	INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
	INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
	INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
	INNER JOIN locations ON assets.id=locations.asset_id)
	INNER JOIN investments ON assets.investment_id=investments.id)
	INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
	INNER JOIN folders ON folders_investments.folder_id=folders.id)
	INNER JOIN groups ON folders.group_id=groups.id)
	INNER JOIN customers ON groups.customer_id=customers.id)
WHERE customers.name=this_cust_name
	AND locations.admin_area_level0=this_nation
	AND groups.name=this_group_name
	AND risk_factors.id IN (SELECT DISTINCT rf_category_risk_factors.risk_factor_id
							FROM ((rf_category_risk_factors
								LEFT JOIN rf_categories ON rf_category_risk_factors.rf_category_id=rf_categories.id)
								INNER JOIN risk_factor_tree ON rf_categories.parent_id=risk_factor_tree.id)
							WHERE risk_factor_tree.name=this_category)
GROUP BY risk_factors.name
ORDER BY fmv_impact DESC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_group_riskfactor_rpt_by_category_scenario_decade_tag" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_scen_id integer;
	this_fmv numeric;
BEGIN
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
SELECT SUM(assets.asset_value) INTO this_fmv
FROM assets
WHERE id IN (SELECT DISTINCT assets.id
			FROM ((((((((((risk_factors
			INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
			INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
			INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
			INNER JOIN assets_tags ON assets.id=assets_tags.asset_id)
			INNER JOIN tags ON assets_tags.tag_id=tags.id)
			INNER JOIN investments ON assets.investment_id=investments.id)
			INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
			INNER JOIN folders ON folders_investments.folder_id=folders.id)
			INNER JOIN groups ON folders.group_id=groups.id)
			INNER JOIN customers ON groups.customer_id=customers.id)
			WHERE customers.name=this_cust_name AND groups.name=this_group_name AND tags.name=this_tag);
RETURN QUERY
WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id)
SELECT risk_factors.name, ROUND(this_fmv,3),
	ROUND(SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)),3) AS fmv_impact,
	ROUND((100 * SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)) / this_fmv),3) AS fmv_pct
FROM ((((((((((risk_factors
	INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
	INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
	INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
	INNER JOIN assets_tags ON assets.id=assets_tags.asset_id)
	INNER JOIN tags ON assets_tags.tag_id=tags.id)
	INNER JOIN investments ON assets.investment_id=investments.id)
	INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
	INNER JOIN folders ON folders_investments.folder_id=folders.id)
	INNER JOIN groups ON folders.group_id=groups.id)
	INNER JOIN customers ON groups.customer_id=customers.id)
WHERE customers.name=this_cust_name AND groups.name=this_group_name AND tags.name=this_tag
	AND risk_factors.id IN (SELECT DISTINCT rf_category_risk_factors.risk_factor_id
							FROM ((rf_category_risk_factors
								LEFT JOIN rf_categories ON rf_category_risk_factors.rf_category_id=rf_categories.id)
								INNER JOIN risk_factor_tree ON rf_categories.parent_id=risk_factor_tree.id)
							WHERE risk_factor_tree.name=this_category)
GROUP BY risk_factors.name
ORDER BY fmv_impact DESC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_impact_timeseries_by_category_scenario" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_scen_id integer;
BEGIN
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
RETURN QUERY
WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id)
SELECT decades.decade,
	ROUND(SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,decades.decade,risk_factors.id)),3) AS fmv_impact
FROM (((((((((risk_factors
	INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
	INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
	INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
	INNER JOIN investments ON assets.investment_id=investments.id)
	INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
	INNER JOIN folders ON folders_investments.folder_id=folders.id)
	INNER JOIN groups ON folders.group_id=groups.id)
	INNER JOIN customers ON groups.customer_id=customers.id)
	CROSS JOIN (VALUES (2010),(2020),(2030),(2040),(2050),(2060),(2070),(2080),(2090)) AS decades (decade))
WHERE customers.name=this_cust_name
	AND risk_factors.id IN (SELECT DISTINCT rf_category_risk_factors.risk_factor_id
							FROM ((rf_category_risk_factors
								LEFT JOIN rf_categories ON rf_category_risk_factors.rf_category_id=rf_categories.id)
								INNER JOIN risk_factor_tree ON rf_categories.parent_id=risk_factor_tree.id)
							WHERE risk_factor_tree.name=this_category)
GROUP BY decades.decade
ORDER BY decades.decade ASC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_impact_timeseries_by_scenario_riskfactor" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_scen_id integer;
	this_riskfactor_id integer;
BEGIN
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
SELECT risk_factors.id INTO this_riskfactor_id FROM risk_factors WHERE name=this_riskfactor;
RETURN QUERY
SELECT decades.decade,
	ROUND(SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,decades.decade,this_riskfactor_id)),3) AS fmv_impact
FROM ((((((assets
	INNER JOIN investments ON assets.investment_id=investments.id)
	INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
	INNER JOIN folders ON folders_investments.folder_id=folders.id)
	INNER JOIN groups ON folders.group_id=groups.id)
	INNER JOIN customers ON groups.customer_id=customers.id)
	CROSS JOIN (VALUES (2010),(2020),(2030),(2040),(2050),(2060),(2070),(2080),(2090)) AS decades (decade))
WHERE customers.name=this_cust_name
GROUP BY decades.decade
ORDER BY decades.decade ASC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_investment_impact_timeseries_by_category_scenario" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_scen_id integer;
BEGIN
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
RETURN QUERY
WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id)
SELECT decades.decade,
	ROUND(SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,decades.decade,risk_factors.id)),3) AS fmv_impact
FROM (((((((((risk_factors
	INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
	INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
	INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
	INNER JOIN investments ON assets.investment_id=investments.id)
	INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
	INNER JOIN folders ON folders_investments.folder_id=folders.id)
	INNER JOIN groups ON folders.group_id=groups.id)
	INNER JOIN customers ON groups.customer_id=customers.id)
	CROSS JOIN (VALUES (2010),(2020),(2030),(2040),(2050),(2060),(2070),(2080),(2090)) AS decades (decade))
WHERE customers.name=this_cust_name
	AND groups.name=this_group_name
	AND folders.name=this_folder_name
	AND investments.name=this_investment_name
	AND risk_factors.id IN (SELECT DISTINCT rf_category_risk_factors.risk_factor_id
							FROM ((rf_category_risk_factors
								LEFT JOIN rf_categories ON rf_category_risk_factors.rf_category_id=rf_categories.id)
								INNER JOIN risk_factor_tree ON rf_categories.parent_id=risk_factor_tree.id)
							WHERE risk_factor_tree.name=this_category)
GROUP BY decades.decade
ORDER BY decades.decade ASC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_investment_riskfactor_rpt_by_category_scenario_decade" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_scen_id integer;
	this_fmv numeric;
BEGIN
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
SELECT SUM(assets.asset_value) INTO this_fmv
FROM assets
WHERE id IN (SELECT DISTINCT assets.id
			FROM ((((((((risk_factors
			INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
			INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
			INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
			INNER JOIN investments ON assets.investment_id=investments.id)
			INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
			INNER JOIN folders ON folders_investments.folder_id=folders.id)
			INNER JOIN groups ON folders.group_id=groups.id)
			INNER JOIN customers ON groups.customer_id=customers.id)
			WHERE customers.name=this_cust_name
				AND groups.name=this_group_name
				AND folders.name=this_folder_name
			 	AND investments.name=this_investment_name);
RETURN QUERY
WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id)
SELECT risk_factors.name, ROUND(this_fmv,3),
	ROUND(SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)),3) AS fmv_impact,
	ROUND((100 * SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)) / this_fmv),3) AS fmv_pct
FROM ((((((((risk_factors
	INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
	INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
	INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
	INNER JOIN investments ON assets.investment_id=investments.id)
	INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
	INNER JOIN folders ON folders_investments.folder_id=folders.id)
	INNER JOIN groups ON folders.group_id=groups.id)
	INNER JOIN customers ON groups.customer_id=customers.id)
WHERE customers.name=this_cust_name
	AND groups.name=this_group_name
	AND folders.name=this_folder_name
	AND investments.name=this_investment_name
	AND risk_factors.id IN (SELECT DISTINCT rf_category_risk_factors.risk_factor_id
							FROM ((rf_category_risk_factors
								LEFT JOIN rf_categories ON rf_category_risk_factors.rf_category_id=rf_categories.id)
								INNER JOIN risk_factor_tree ON rf_categories.parent_id=risk_factor_tree.id)
							WHERE risk_factor_tree.name=this_category)
GROUP BY risk_factors.name
ORDER BY fmv_impact DESC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_nation_impact_rpt_by_category_scenario_decade" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_scen_id integer;
	this_fmv numeric;
BEGIN
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
SELECT SUM(assets.asset_value) INTO this_fmv
FROM assets
WHERE id IN (SELECT DISTINCT assets.id
			FROM ((((((((risk_factors
			INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
			INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
			INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
			INNER JOIN investments ON assets.investment_id=investments.id)
			INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
			INNER JOIN folders ON folders_investments.folder_id=folders.id)
			INNER JOIN groups ON folders.group_id=groups.id)
			INNER JOIN customers ON groups.customer_id=customers.id)
			WHERE customers.name=this_cust_name);
RETURN QUERY
WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id)
SELECT locations.admin_area_level0, ROUND(this_fmv,3),
	ROUND(SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)),3) AS fmv_impact,
	ROUND((100 * SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)) / this_fmv),3) AS fmv_pct
FROM ((((((((((risk_factors
	INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
	INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
	INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
	INNER JOIN locations ON assets.id=locations.asset_id)
	INNER JOIN asset_types ON assets.asset_type_id=asset_types.id)
	INNER JOIN investments ON assets.investment_id=investments.id)
	INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
	INNER JOIN folders ON folders_investments.folder_id=folders.id)
	INNER JOIN groups ON folders.group_id=groups.id)
	INNER JOIN customers ON groups.customer_id=customers.id)
WHERE customers.name=this_cust_name
	AND risk_factors.id IN (SELECT DISTINCT rf_category_risk_factors.risk_factor_id
							FROM ((rf_category_risk_factors
								LEFT JOIN rf_categories ON rf_category_risk_factors.rf_category_id=rf_categories.id)
								INNER JOIN risk_factor_tree ON rf_categories.parent_id=risk_factor_tree.id)
							WHERE risk_factor_tree.name=this_category)
GROUP BY locations.admin_area_level0
ORDER BY fmv_impact DESC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_riskfactor_rpt_by_category_scenario_decade" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_scen_id integer;
	this_fmv numeric;
BEGIN
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
SELECT SUM(assets.asset_value) INTO this_fmv
FROM assets
WHERE id IN (SELECT DISTINCT assets.id
			FROM ((((((((risk_factors
			INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
			INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
			INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
			INNER JOIN investments ON assets.investment_id=investments.id)
			INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
			INNER JOIN folders ON folders_investments.folder_id=folders.id)
			INNER JOIN groups ON folders.group_id=groups.id)
			INNER JOIN customers ON groups.customer_id=customers.id)
			WHERE customers.name=this_cust_name);
RETURN QUERY
WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id)
SELECT risk_factors.name, ROUND(this_fmv,3),
	ROUND(SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)),3) AS fmv_impact,
	ROUND((100 * SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)) / this_fmv),3) AS fmv_pct
FROM ((((((((risk_factors
	INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
	INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
	INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
	INNER JOIN investments ON assets.investment_id=investments.id)
	INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
	INNER JOIN folders ON folders_investments.folder_id=folders.id)
	INNER JOIN groups ON folders.group_id=groups.id)
	INNER JOIN customers ON groups.customer_id=customers.id)
WHERE customers.name=this_cust_name
	AND risk_factors.id IN (SELECT DISTINCT rf_category_risk_factors.risk_factor_id
							FROM ((rf_category_risk_factors
								LEFT JOIN rf_categories ON rf_category_risk_factors.rf_category_id=rf_categories.id)
								INNER JOIN risk_factor_tree ON rf_categories.parent_id=risk_factor_tree.id)
							WHERE risk_factor_tree.name=this_category)
GROUP BY risk_factors.name
ORDER BY fmv_impact DESC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_riskfactor_rpt_by_category_scenario_decade_nation" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_scen_id integer;
	this_fmv numeric;
BEGIN
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
SELECT SUM(assets.asset_value) INTO this_fmv
FROM assets
WHERE id IN (SELECT DISTINCT assets.id
			FROM (((((((((risk_factors
			INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
			INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
			INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
			INNER JOIN locations ON assets.id=locations.asset_id)
			INNER JOIN investments ON assets.investment_id=investments.id)
			INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
			INNER JOIN folders ON folders_investments.folder_id=folders.id)
			INNER JOIN groups ON folders.group_id=groups.id)
			INNER JOIN customers ON groups.customer_id=customers.id)
			WHERE customers.name=this_cust_name
				AND locations.admin_area_level0=this_nation);
RETURN QUERY
WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id)
SELECT risk_factors.name, ROUND(this_fmv,3),
	ROUND(SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)),3) AS fmv_impact,
	ROUND((100 * SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)) / this_fmv),3) AS fmv_pct
FROM (((((((((risk_factors
	INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
	INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
	INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
	INNER JOIN locations ON assets.id=locations.asset_id)
	INNER JOIN investments ON assets.investment_id=investments.id)
	INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
	INNER JOIN folders ON folders_investments.folder_id=folders.id)
	INNER JOIN groups ON folders.group_id=groups.id)
	INNER JOIN customers ON groups.customer_id=customers.id)
WHERE customers.name=this_cust_name
	AND locations.admin_area_level0=this_nation
	AND risk_factors.id IN (SELECT DISTINCT rf_category_risk_factors.risk_factor_id
							FROM ((rf_category_risk_factors
								LEFT JOIN rf_categories ON rf_category_risk_factors.rf_category_id=rf_categories.id)
								INNER JOIN risk_factor_tree ON rf_categories.parent_id=risk_factor_tree.id)
							WHERE risk_factor_tree.name=this_category)
GROUP BY risk_factors.name
ORDER BY fmv_impact DESC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cust_riskfactor_rpt_by_category_scenario_decade_tag" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_scen_id integer;
	this_fmv numeric;
BEGIN
SELECT scenarios.id INTO this_scen_id FROM scenarios WHERE name_etl=this_scen_name;
SELECT SUM(assets.asset_value) INTO this_fmv
FROM assets
WHERE id IN (SELECT DISTINCT assets.id
			FROM ((((((((((risk_factors
			INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
			INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
			INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
			INNER JOIN assets_tags ON assets.id=assets_tags.asset_id)
			INNER JOIN tags ON assets_tags.tag_id=tags.id)
			INNER JOIN investments ON assets.investment_id=investments.id)
			INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
			INNER JOIN folders ON folders_investments.folder_id=folders.id)
			INNER JOIN groups ON folders.group_id=groups.id)
			INNER JOIN customers ON groups.customer_id=customers.id)
			WHERE customers.name=this_cust_name AND tags.name=this_tag);
RETURN QUERY
WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id)
SELECT risk_factors.name, ROUND(this_fmv,3),
	ROUND(SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)),3) AS fmv_impact,
	ROUND((100 * SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id,this_scen_id,this_decade,risk_factors.id)) / this_fmv),3) AS fmv_pct
FROM ((((((((((risk_factors
	INNER JOIN impact_functions ON risk_factors.id=impact_functions.risk_factor_id)
	INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
	INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
	INNER JOIN assets_tags ON assets.id=assets_tags.asset_id)
	INNER JOIN tags ON assets_tags.tag_id=tags.id)
	INNER JOIN investments ON assets.investment_id=investments.id)
	INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
	INNER JOIN folders ON folders_investments.folder_id=folders.id)
	INNER JOIN groups ON folders.group_id=groups.id)
	INNER JOIN customers ON groups.customer_id=customers.id)
WHERE customers.name=this_cust_name AND tags.name=this_tag
	AND risk_factors.id IN (SELECT DISTINCT rf_category_risk_factors.risk_factor_id
							FROM ((rf_category_risk_factors
								LEFT JOIN rf_categories ON rf_category_risk_factors.rf_category_id=rf_categories.id)
								INNER JOIN risk_factor_tree ON rf_categories.parent_id=risk_factor_tree.id)
							WHERE risk_factor_tree.name=this_category)
GROUP BY risk_factors.name
ORDER BY fmv_impact DESC;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="customer_aggregates_update_impacts" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
-- Clear existing
DELETE FROM aggregate_impacts WHERE aggregate_level=6 AND entity_id=this_entity_id;
-- Insert totals row
INSERT INTO aggregate_impacts (aggregate_level, entity_id, tags_hash_md5, risk_factor_id, scenario_id, yr, impact_abs)
SELECT 6 AS level, this_entity_id, tags_hash_md5, risk_factor_id, scenario_id, yr, SUM(impact_abs)
FROM aggregate_impacts
WHERE aggregate_level=3 AND entity_id IN (SELECT DISTINCT folders_investments.investment_id
										  FROM ((folders_investments INNER JOIN folders ON folders_investments.folder_id=folders.id)
												INNER JOIN groups ON folders.group_id=groups.id)
										  WHERE groups.customer_id=this_entity_id)
GROUP BY tags_hash_md5, risk_factor_id, scenario_id, yr ORDER BY tags_hash_md5, risk_factor_id, scenario_id, yr;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="customer_aggregates_update_totals" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
-- Clear existing
DELETE FROM aggregate_totals WHERE aggregate_level=6 AND entity_id=this_entity_id;
-- Insert totals row
INSERT INTO aggregate_totals (aggregate_level, entity_id, tags_hash_md5, qty_children, qty_children_done,
							  value_abs, qty_assets, qty_assets_complete_hazards, qty_assets_complete_risks)
SELECT 6 AS level, this_entity_id, tags_hash_md5,
	customer_qty_groups(this_entity_id, tags_hash_md5),
	customer_qty_groups_aggregated(this_entity_id, tags_hash_md5),
	SUM(value_abs), SUM(qty_assets), SUM(qty_assets_complete_hazards), SUM(qty_assets_complete_risks)
FROM aggregate_totals
WHERE aggregate_level=3 AND entity_id IN (SELECT DISTINCT folders_investments.investment_id
										  FROM ((folders_investments INNER JOIN folders ON folders_investments.folder_id=folders.id)
												INNER JOIN groups ON folders.group_id=groups.id)
										  WHERE groups.customer_id=this_entity_id)
GROUP BY tags_hash_md5;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="customer_flag_to_eval" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT group_flag_to_eval(id) FROM groups WHERE customer_id=this_entity_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="customer_qty_groups" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	total integer := 0;
BEGIN
	IF this_hash=MD5('') THEN -- No tags
		SELECT COUNT(*)::integer INTO total FROM groups
		WHERE customer_id=this_entity_id
			AND group_qty_folders(groups.id, MD5(''))>0;
	ELSE -- Tags
		SELECT COUNT(DISTINCT groups.id)::integer INTO total
		FROM (groups
			  INNER JOIN aggregate_totals ON groups.id=aggregate_totals.entity_id)
		WHERE aggregate_level=5
			AND groups.customer_id=this_entity_id
			AND tags_hash_md5=this_hash
			AND group_qty_folders(groups.id, this_hash)>0;
	END IF;
	RETURN total;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="customer_qty_groups_aggregated" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT COUNT(*)::integer
FROM (groups INNER JOIN aggregate_totals ON groups.id=aggregate_totals.entity_id)
WHERE aggregate_level=5
	AND groups.customer_id=this_entity_id
	AND tags_hash_md5=this_hash
	AND qty_children_done=qty_children;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="deactivate_asset" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
UPDATE assets SET is_active=0 WHERE id=this_asset_id; -- Set flag
	-- Delete asset level aggregate_impacts and _totals
	DELETE FROM aggregate_totals WHERE aggregate_level=2 AND entity_id=this_asset_id;
	DELETE FROM aggregate_impacts WHERE aggregate_level=2 AND entity_id=this_asset_id;
	-- Call aggregate investment
	SELECT aggregates_update(3, assets.investment_id) FROM assets WHERE id=this_asset_id; -- For investment level
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="decadal_states_approximate" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	rec RECORD;
	this_lngid integer;
	this_latid integer;
	k integer;
	w numeric := 0; -- Weighted sum
	d numeric := 0; -- Total distance
	m numeric := 0; -- Weighted mean;
	span_lng numeric := 1;
	span_lat numeric := 1;
	x integer;
BEGIN
	RAISE NOTICE 'gridsquare_id: %', this_gridsquare_id;
	SELECT INTO this_lngid serial_lngid FROM grid_squares WHERE id=this_gridsquare_id;
	SELECT INTO this_latid serial_latid FROM grid_squares WHERE id=this_gridsquare_id;
	RAISE NOTICE 'latid: %, lngid: %', this_latid, this_lngid;
	SELECT INTO k val FROM app_controls WHERE name='decadal_states_approximate_method_knn_k';
	RAISE NOTICE 'k: %', k;
	FOR rec in (SELECT *,
					sqrt(power(grid_squares.serial_lngid-this_lngid,2)+power(grid_squares.serial_latid-this_latid,2)) AS dist
				FROM (decadal_states
					  INNER JOIN grid_squares
					  ON decadal_states.grid_square_id=grid_squares.id)
				WHERE hazard_metric_id=this_hazmet_id
					AND scenario_id=this_scen_id
					AND decade=this_decade
					AND decadal_states.approximated=false
				LIMIT k) LOOP
		RAISE NOTICE 'mean: %', rec.hazard_metric_mean;
		w := w + rec.hazard_metric_mean/rec.dist;
		d := d + 1/rec.dist;
		x := ABS(rec.serial_lngid-this_lngid);
		IF x>span_lng THEN
			span_lng := x;
		END IF;
		x := ABS(rec.serial_latid-this_latid);
		IF x>span_lat THEN
			span_lat := x;
		END IF;
		RAISE NOTICE 'w: %, d: %, spanlng: %, spanlat: %', w, d, span_lng, span_lat;
	END LOOP;
	IF d>0 THEN
		m := w/d;
		RAISE NOTICE 'new mean: %', m;
		DELETE FROM decadal_states
			WHERE grid_square_id=this_gridsquare_id
				AND hazard_metric_id=this_hazmet_id
				AND scenario_id=this_scen_id
				AND decade=this_decade
				AND approximated=true;
		INSERT INTO decadal_states (grid_square_id,
									decadal_state_type,
									hazard_metric_id,
									scenario_id,
									decade,
									hazard_metric_mean,
									approximated,
									approximated_gridsquare_span_lng,
									approximated_gridsquare_span_lat)
							VALUES (this_gridsquare_id,
									1,
									this_hazmet_id,
									this_scen_id,
									this_decade,
									m,
									true,
									span_lng,
									span_lat);
	END IF;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="decadal_states_clear_by_location_point_hazards" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
DELETE
FROM decadal_states
WHERE decadal_states.decadal_state_type=2
	AND decadal_states.point_loc_id=this_loc_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="delete_subscription" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
                     persist_dblink_extension boolean;
                BEGIN
                    persist_dblink_extension := create_dblink_extension();
                    PERFORM dblink_connect(format('dbname=%s', db_name));
                    PERFORM dblink_exec(format('Drop SUBSCRIPTION %s',subscription_name));
                    PERFORM dblink_disconnect();

                    IF persist_dblink_extension = FALSE
                    THEN
                        DROP EXTENSION IF EXISTS dblink;
                    END IF;
                    RETURN 'ok';
                END
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="disable_subscription" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
                     persist_dblink_extension boolean;
                BEGIN
                    persist_dblink_extension := create_dblink_extension();
                    PERFORM dblink_connect(format('dbname=%s', db_name));
                    PERFORM dblink_exec(format('ALTER SUBSCRIPTION %s DISABLE',subscription_name));
                    PERFORM dblink_disconnect();
                    IF persist_dblink_extension = FALSE
                    THEN
                        DROP EXTENSION IF EXISTS dblink;
                    END IF;
                    RETURN 'ok';
                END
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="enable_subscription" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
                     persist_dblink_extension boolean;
                BEGIN
                    persist_dblink_extension := create_dblink_extension();
                    PERFORM dblink_connect(format('dbname=%s', db_name));
                    PERFORM dblink_exec(format('ALTER SUBSCRIPTION %s ENABLE',subscription_name));
                    PERFORM dblink_disconnect();
                    IF persist_dblink_extension = FALSE
                    THEN
                        DROP EXTENSION IF EXISTS dblink;
                    END IF;
                    RETURN 'ok';
                END
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="etl_gridded_data_process" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
UPDATE etl_gridded_data SET proc_stage_complete=0 WHERE etl_batch=batchnum;
INSERT INTO grid_squares(grid_id, serial_lngid, serial_latid, name_etl)
SELECT DISTINCT grids.id, etl_gridded_data.etl_grid_square_serial_lngid, etl_gridded_data.etl_grid_square_serial_latid, etl_gridded_data.etl_grid_square_name
FROM grids INNER JOIN etl_gridded_data ON grids.name_etl=etl_gridded_data.etl_grid_system_name
WHERE etl_gridded_data.proc_stage_complete=0
AND etl_gridded_data.etl_batch=batchnum
AND etl_gridded_data.etl_grid_square_name NOT IN (SELECT DISTINCT name_etl
FROM grid_squares);
UPDATE etl_gridded_data SET proc_stage_complete=10 WHERE etl_batch=batchnum;
DELETE FROM decadal_states WHERE decadal_states.decadal_state_type=1
	AND decadal_states.id IN
(SELECT DISTINCT decadal_states.id FROM ((((decadal_states
	INNER JOIN grid_squares ON decadal_states.grid_square_id=grid_squares.id)
	INNER JOIN hazard_metrics ON decadal_states.hazard_metric_id=hazard_metrics.id)
	INNER JOIN scenarios ON decadal_states.scenario_id=scenarios.id)
	INNER JOIN etl_gridded_data ON etl_gridded_data.decade=decadal_states.decade
		AND etl_gridded_data.etl_grid_square_name=grid_squares.name_etl
		AND etl_gridded_data.etl_hazard_metric_name=hazard_metrics.name_etl
		AND etl_gridded_data.etl_scenario_name=scenarios.name_etl)
	WHERE etl_gridded_data.etl_batch=batchnum);
INSERT INTO decadal_states(decadal_state_type, grid_square_id, hazard_metric_id, scenario_id, decade, hazard_metric_mean)
SELECT DISTINCT 1, grid_squares.id, hazard_metrics.id, scenarios.id, etl_gridded_data.decade, etl_gridded_data.hazard_metric_mean
FROM (((etl_gridded_data INNER JOIN grid_squares ON etl_gridded_data.etl_grid_square_name=grid_squares.name_etl)
	 INNER JOIN hazard_metrics ON etl_gridded_data.etl_hazard_metric_name=hazard_metrics.name_etl)
	 INNER JOIN scenarios ON etl_gridded_data.etl_scenario_name=scenarios.name_etl)
WHERE etl_gridded_data.proc_stage_complete=10
AND etl_gridded_data.etl_batch=batchnum;
UPDATE etl_gridded_data SET proc_stage_complete=100 WHERE etl_batch=batchnum;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="etl_gridded_data_process_upsert" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
UPDATE etl_gridded_data SET proc_stage_complete=0 WHERE etl_batch=batchnum;
INSERT INTO grid_squares(grid_id, serial_lngid, serial_latid, name_etl, version)
	(SELECT DISTINCT grids.id, etl_gridded_data.etl_grid_square_serial_lngid, etl_gridded_data.etl_grid_square_serial_latid, etl_gridded_data.etl_grid_square_name, data_version
	FROM grids INNER JOIN etl_gridded_data ON grids.name_etl=etl_gridded_data.etl_grid_system_name
	WHERE etl_gridded_data.proc_stage_complete=0
	AND etl_gridded_data.etl_batch=batchnum)
ON CONFLICT ON CONSTRAINT grid_squares_c01
	DO UPDATE SET version=data_version;
UPDATE etl_gridded_data SET proc_stage_complete=10 WHERE etl_batch=batchnum;
INSERT INTO decadal_states(decadal_state_type, grid_square_id, hazard_metric_id, scenario_id, decade, hazard_metric_mean, approximated, approximated_gridsquare_span_lng, approximated_gridsquare_span_lat)
	(SELECT DISTINCT 1, grid_squares.id, hazard_metrics.id, scenarios.id, etl_gridded_data.decade, etl_gridded_data.hazard_metric_mean, false, 1, 1
	FROM (((etl_gridded_data INNER JOIN grid_squares ON etl_gridded_data.etl_grid_square_name=grid_squares.name_etl)
		 INNER JOIN hazard_metrics ON etl_gridded_data.etl_hazard_metric_name=hazard_metrics.name_etl)
		 INNER JOIN scenarios ON etl_gridded_data.etl_scenario_name=scenarios.name_etl)
	WHERE etl_gridded_data.proc_stage_complete=10
	AND etl_gridded_data.etl_batch=batchnum)
ON CONFLICT ON CONSTRAINT decadal_states_c03
	DO UPDATE SET hazard_metric_mean=EXCLUDED.hazard_metric_mean, approximated=false,
		approximated_gridsquare_span_lng=1, approximated_gridsquare_span_lat=1;
UPDATE etl_gridded_data SET proc_stage_complete=100 WHERE etl_batch=batchnum;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="feed_trigger" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
  rec RECORD;
  location_query TEXT;
  location_rec RECORD;
  location_array JSON[] := '{}';
  payload TEXT;
  notification_channel TEXT := 'feed-assets';
  t timestamptz := clock_timestamp();
BEGIN

  /*
    Set record row depending on operation
    
    AND

    Assigning Grid squares upon creation of a Location -
    This is safe as the function checks for the existence of grid squares,
    and other functions remove them if an action is an UPDATE
  */ 
  CASE TG_OP
  WHEN 'INSERT' THEN
    rec := NEW;
    PERFORM loc_gridsquares_assign(rec.id, 'nexgddp'); -- Assign NEXGDDP grid squares
  WHEN 'UPDATE' THEN
    rec := NEW;
    PERFORM loc_gridsquares_unassign(rec.id, 'nexgddp'); -- Unassign grid squares
    PERFORM loc_gridsquares_assign(rec.id, 'nexgddp'); -- Assign NEXGDDP grid squares
  WHEN 'DELETE' THEN
    rec := OLD;
  ELSE
     RAISE EXCEPTION 'Unknown TG_OP trigger operation: "%".', TG_OP;
  END CASE;

  /*
    Intent will be to use locations.asset_id and perform this whenever an Asset-related
    transaction completes, but for now using on individual Locations
  */ 
  location_query := 'SELECT locations.id, serial_lngid, serial_latid, geo_lng_positive(lng::numeric), lat, lng, elevation_m_rel2lmsl as elevation
    FROM locations 
    INNER JOIN loc_grid_squares ON locations.id=loc_grid_squares.loc_id 
    INNER JOIN grid_squares ON loc_grid_squares.grid_square_id=grid_squares.id 
    INNER JOIN grids ON grid_squares.grid_id=grids.id 
    WHERE locations.id = $1 AND grids.name_etl=$2';
  
  FOR location_rec IN EXECUTE location_query USING rec.id, 'nexgddp'
  LOOP
    location_array := location_array || row_to_json(location_rec);
  END LOOP;

  payload := json_build_object(
    'timestamp',CURRENT_TIMESTAMP,
    'operation',TG_OP,
    'schema',TG_TABLE_SCHEMA,
    'table',TG_TABLE_NAME,
    'data', json_build_object('locations',location_array)
  );

  -- Notify the channel
  PERFORM pg_notify(notification_channel, payload);
  RAISE NOTICE 'feed_trigger execution duration: %', clock_timestamp() - t;
  RETURN rec;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="folder_aggregates_update_impacts" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
-- Clear existing
DELETE FROM aggregate_impacts WHERE aggregate_level=4 AND entity_id=this_entity_id;
-- Insert totals row
INSERT INTO aggregate_impacts (aggregate_level, entity_id, tags_hash_md5, risk_factor_id, scenario_id, yr, impact_abs)
SELECT 4 AS level, this_entity_id, tags_hash_md5, risk_factor_id, scenario_id, yr, SUM(impact_abs)
FROM aggregate_impacts
WHERE aggregate_level=3 AND entity_id IN (SELECT DISTINCT folders_investments.investment_id
										  FROM folders_investments WHERE folders_investments.folder_id=this_entity_id)
GROUP BY tags_hash_md5, risk_factor_id, scenario_id, yr ORDER BY tags_hash_md5, risk_factor_id, scenario_id, yr;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="folder_aggregates_update_totals" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
-- Clear existing
DELETE FROM aggregate_totals WHERE aggregate_level=4 AND entity_id=this_entity_id;
-- Insert totals row
INSERT INTO aggregate_totals (aggregate_level, entity_id, tags_hash_md5, qty_children, qty_children_done, value_abs,
							  qty_assets, qty_assets_complete_hazards, qty_assets_complete_risks)
SELECT 4 AS level, this_entity_id, tags_hash_md5, folder_qty_investments(this_entity_id, tags_hash_md5),
		folder_qty_investments_aggregated(this_entity_id, tags_hash_md5),
		SUM(value_abs), SUM(qty_assets), SUM(qty_assets_complete_hazards), SUM(qty_assets_complete_risks)
FROM aggregate_totals
WHERE aggregate_level=3 AND entity_id IN (SELECT DISTINCT folders_investments.investment_id
										  FROM folders_investments WHERE folders_investments.folder_id=this_entity_id)
GROUP BY tags_hash_md5;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="folder_flag_to_eval" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT investment_flag_to_eval(investment_id) FROM folders_investments WHERE folder_id=this_entity_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="folder_fmv" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT SUM(asset_value)::numeric AS folder_fmv_m_usd
FROM assets
WHERE id IN (SELECT DISTINCT assets.id
			FROM ((assets
				INNER JOIN investments ON assets.investment_id=investments.id)
				INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
WHERE folders_investments.folder_id=this_folder_id);
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="folder_impact_to_fmv_by_scenario_decade_category" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
WITH RECURSIVE risk_factor_tree AS (
        SELECT id, name, parent_id
        FROM rf_categories
        UNION
        SELECT rf_categories.id, rf_categories.name, rf_categories.parent_id
        FROM rf_categories
        INNER JOIN risk_factor_tree rftree ON rf_categories.id = rftree.parent_id)
SELECT SUM(folder_impact_to_fmv_by_scenario_decade_riskfactor(this_folder_id,this_scen_id,this_decade,risk_factors.id))
		AS fmv_impact_m_usd
FROM risk_factors
WHERE risk_factors.id IN (SELECT DISTINCT rf_category_risk_factors.risk_factor_id
							FROM ((rf_category_risk_factors
								LEFT JOIN rf_categories ON rf_category_risk_factors.rf_category_id=rf_categories.id)
								INNER JOIN risk_factor_tree ON rf_categories.parent_id=risk_factor_tree.id)
							WHERE risk_factor_tree.name=this_category);
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="folder_impact_to_fmv_by_scenario_decade_riskfactor" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT SUM(investment_impact_to_fmv_by_scenario_decade_riskfactor(folders_investments.investment_id, this_scen_id, this_decade, this_risk_factor_id))
FROM folders_investments
WHERE folders_investments.folder_id=this_folder_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="folder_qty_investments" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	total integer := 0;
BEGIN
	IF this_hash=MD5('') THEN -- No tags
		SELECT COUNT(DISTINCT investment_id)::integer INTO total
		FROM folders_investments
		WHERE folders_investments.folder_id=this_entity_id
			AND investment_qty_assets(investment_id, MD5(''))>0;
	ELSE -- Tags
		SELECT COUNT(DISTINCT investment_id)::integer INTO total
		FROM (folders_investments
			  INNER JOIN aggregate_totals ON folders_investments.investment_id=aggregate_totals.entity_id)
		WHERE aggregate_level=3
			AND folders_investments.folder_id=this_entity_id
			AND tags_hash_md5=this_hash
			AND investment_qty_assets(investment_id, this_hash)>0;
	END IF;
	RETURN total;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="folder_qty_investments_aggregated" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT COUNT(*)::integer
FROM (folders_investments
	 INNER JOIN aggregate_totals ON folders_investments.investment_id=aggregate_totals.entity_id)
WHERE aggregate_level=3
	AND folders_investments.folder_id=this_entity_id
	AND tags_hash_md5=this_hash
	AND qty_children_done=qty_children;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geo_lng_positive" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
BEGIN
    IF (lng < 0) THEN lng := (lng + 360); END IF;
	RETURN lng;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="grid_square_name_loca" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	s double precision := 0.0625;
	square_id character varying;
	minlat numeric := 23.40625 - (0.5 * s);
	maxlat numeric := 53.96875 + (0.5 * s);
	minlon numeric := 234.03125 - (0.5 * s);
	maxlon numeric := 293.96875 + (0.5 * s);
	nlon double precision;
	mlon double precision;
	nlat double precision;
	mlat double precision;
	lat_id character varying;
	lon_id character varying;
BEGIN
    IF (lon < 0) THEN lon := (lon + 360); END IF;
	IF (lat >= minlat AND lat <= maxlat AND lon >= minlon AND lon <= maxlon) THEN
		nlon := MOD(CAST((lon - minlon) AS numeric), CAST(s AS numeric));
		IF (nlon=0) THEN mlon := 0; ELSE mlon := 1; END IF;
      	lon_id := floor((lon - minlon) / s) + mlon - 1;
      	nlat := CAST(lat AS numeric) % CAST(s AS numeric);
		IF (nlat=0) THEN mlat := 0; ELSE mlat := 1; END IF;
      	lat_ID := floor((lat - minlat) / s) + mlat - 1;
        IF (lon_id='-1') THEN lon_id := 0; END IF;
		IF (lat_id='-1') THEN lat_id := 0; END IF;
		square_id := 'loca_' || lon_id || '_' || lat_id;
	ELSE
		square_id := 'outside_loca_region';
	END IF;
	RETURN square_id;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="grid_square_name_make" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	square_id character varying;
BEGIN
	IF gridname='loca' THEN
		SELECT grid_square_name_loca(lat, lon) INTO square_id;
	ELSEIF gridname='nexgddp' THEN
		SELECT grid_square_name_nexgddp(CAST(lat AS numeric), CAST(lon AS numeric)) INTO square_id;
	ELSE
		square_id := null;
	END IF;
	RETURN square_id;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="grid_square_name_nexgddp" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	s numeric := 0.25;
	square_id character varying;
	nlon numeric;
	mlon numeric;
	nlat numeric;
	mlat numeric;
	lonoffset numeric;
	latoffset numeric;
	lat_id numeric;
	lon_id numeric;
	total integer;
BEGIN
    IF (lon < 0) THEN lon := (lon + 360); END IF;
	nlon := modulus(lon, s);
	IF (nlon=0) THEN mlon := 0; ELSE mlon := 1; END IF;
	IF (lon=0) THEN lonoffset := 1; ELSEIF (lon=360) THEN lonoffset := -1439; ELSE lonoffset := 0; END IF;
	lon_id := round((lon-MOD(lon,s))/s) + mlon - 1 + lonoffset;
	nlat := modulus(lat, s);
	IF (nlat=0) THEN mlat := 0; ELSE mlat := 1; END IF;
	IF (lat>=0) THEN latoffset := 360; ELSE latoffset := 359; END IF;
	lat_id := round((lat-MOD(lat,s))/s) + mlat - 1 + latoffset;
	IF lon_id<0 THEN lon_id := 0; END IF;
	IF lat_id<0 THEN lat_id := 0; END IF;
	square_id := 'nexgddp_' || lon_id || '_' || lat_id;
	SELECT INTO total COUNT(*) FROM grid_squares WHERE name_etl=square_id;
	IF total=0 THEN
		INSERT INTO grid_squares (grid_id, serial_lngid, serial_latid, name_etl)
			VALUES ((SELECT id FROM grids WHERE name_etl='nexgddp'), lon_id, lat_id, square_id);
	END IF;
	RETURN square_id;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="group_aggregates_update_impacts" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
-- Clear existing
DELETE FROM aggregate_impacts WHERE aggregate_level=5 AND entity_id=this_entity_id;
-- Insert totals row
INSERT INTO aggregate_impacts (aggregate_level, entity_id, tags_hash_md5, risk_factor_id, scenario_id, yr, impact_abs)
SELECT 5 AS level, this_entity_id, tags_hash_md5, risk_factor_id, scenario_id, yr, SUM(impact_abs)
FROM aggregate_impacts
WHERE aggregate_level=3 AND entity_id IN (SELECT DISTINCT folders_investments.investment_id
										  FROM (folders_investments INNER JOIN folders ON folders_investments.folder_id=folders.id)
										  WHERE folders.group_id=this_entity_id)
GROUP BY tags_hash_md5, risk_factor_id, scenario_id, yr ORDER BY tags_hash_md5, risk_factor_id, scenario_id, yr;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="group_aggregates_update_totals" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
-- Clear existing
DELETE FROM aggregate_totals WHERE aggregate_level=5 AND entity_id=this_entity_id;
-- Insert totals row
INSERT INTO aggregate_totals (aggregate_level, entity_id, tags_hash_md5, qty_children, qty_children_done,
							  value_abs, qty_assets, qty_assets_complete_hazards, qty_assets_complete_risks)
SELECT 5 AS level, this_entity_id, tags_hash_md5,
	group_qty_folders(this_entity_id, tags_hash_md5),
	group_qty_folders_aggregated(this_entity_id, tags_hash_md5),
	SUM(value_abs), SUM(qty_assets), SUM(qty_assets_complete_hazards), SUM(qty_assets_complete_risks)
FROM aggregate_totals
WHERE aggregate_level=3 AND entity_id IN (SELECT DISTINCT folders_investments.investment_id
										  FROM (folders_investments INNER JOIN folders ON folders_investments.folder_id=folders.id)
										  WHERE folders.group_id=this_entity_id)
GROUP BY tags_hash_md5;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="group_flag_to_eval" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT folder_flag_to_eval(id) FROM folders WHERE group_id=this_entity_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="group_fmv" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT SUM(asset_value)::numeric AS group_fmv_m_usd
FROM assets
WHERE id IN (SELECT DISTINCT assets.id
			FROM (((assets
				INNER JOIN investments ON assets.investment_id=investments.id)
				INNER JOIN folders_investments ON investments.id=folders_investments.investment_id)
				INNER JOIN folders ON folders_investments.folder_id=folders.id)
WHERE folders.group_id=this_group_id);
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="group_qty_folders" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	total integer := 0;
BEGIN
	IF this_hash=MD5('') THEN -- No tags
		SELECT COUNT(*)::integer INTO total FROM folders
		WHERE group_id=this_entity_id
			AND folder_qty_investments(folders.id, MD5(''))>0;
	ELSE -- Tags
		SELECT COUNT(DISTINCT folders.id)::integer INTO total
		FROM (folders
			  INNER JOIN aggregate_totals ON folders.id=aggregate_totals.entity_id)
		WHERE aggregate_level=4
			AND folders.group_id=this_entity_id
			AND tags_hash_md5=this_hash
			AND folder_qty_investments(folders.id, this_hash)>0;
	END IF;
	RETURN total;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="group_qty_folders_aggregated" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT COUNT(*)::integer
FROM (folders INNER JOIN aggregate_totals ON folders.id=aggregate_totals.entity_id)
WHERE aggregate_level=4
	AND folders.group_id=this_entity_id
	AND tags_hash_md5=this_hash
	AND qty_children_done=qty_children;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hazard_feed_risk_score_proc_n" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
    qty_remaining integer := 0;
    qty_in_progress integer := 0;
    t timestamptz := clock_timestamp();
BEGIN
    -- Clear any scoring request updates related to disabled assets
    DELETE FROM updates WHERE id IN -- Locations of disabled assets
        (SELECT updates.id
         FROM ((updates INNER JOIN locations ON updates.entity_id=locations.id)
              INNER JOIN assets ON locations.asset_id=assets.id)
         WHERE updates.entity_type=1 AND (updates.action=100 OR updates.action=101) AND assets.is_active=0);

    -- Set any aggregation request updates related to unlinked assets as unnecessary
    UPDATE updates SET scoring_status = 1, aggregation_status = 1 WHERE entity_type = 1 AND entity_id IN 
    (SELECT distinct updates.entity_id 
        FROM updates INNER JOIN 
        locations ON updates.entity_id = locations.id INNER JOIN assets ON locations.asset_id = assets.id LEFT JOIN 
        folders_investments ON assets.investment_id = folders_investments.investment_id LEFT JOIN 
        folders ON folders_investments.folder_id = folders.id LEFT JOIN groups ON folders.group_id = groups.id 
        WHERE updates.entity_type = 1 AND assets.is_active = 1 AND groups.customer_id IS NULL
    );

    -- Anything already in progress?
    SELECT INTO qty_in_progress COUNT(id) FROM updates WHERE scoring_status=-1 AND entity_type=1 AND (action=100 OR action=101);
    IF qty_in_progress>0 THEN qty_remaining=-1; -- Something is still in progress
    ELSE -- Mark batch of locations and handle them
        IF earliest_or_latest='latest' THEN
            UPDATE updates SET scoring_status=-1 WHERE id IN
                (SELECT id FROM updates WHERE scoring_status=0 AND entity_type=1 AND (action=100 OR action=101) ORDER BY id DESC LIMIT qty_to_process);
        ELSE
            UPDATE updates SET scoring_status=-1 WHERE id IN
                (SELECT id FROM updates WHERE scoring_status=0 AND entity_type=1 AND (action=100 OR action=101) ORDER BY id ASC LIMIT qty_to_process);
        END IF;
        PERFORM score_location(entity_id) FROM updates WHERE scoring_status=-1 AND entity_type=1 AND (action=100 OR action=101); -- Locations
        UPDATE updates SET scoring_status=1 WHERE scoring_status=-1 AND entity_type=1 AND (action=100 OR action=101); -- Mark batch as done
        SELECT INTO qty_remaining COUNT(DISTINCT id) FROM updates WHERE scoring_status!=1 AND entity_type=1 AND (action=100 OR action=101); -- Get qty_remaining
    END IF;
    RAISE NOTICE 'hazard_feed_risk_score_proc_n execution duration: %', clock_timestamp() - t;
    RETURN qty_remaining; -- Return qty_remaining (or -1 for in progress)
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="impactfn_queue_locations_eval" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
-- Create update entries for locations related to this impact function
    -- Unless they already exist
    INSERT INTO updates (entity_type, entity_id, action, scoring_status)
    SELECT 1, locations.id, 101, 0
    FROM ((assets_impact_functions
            INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
            INNER JOIN locations ON assets.id=locations.asset_id)
    WHERE assets_impact_functions.impact_function_id=this_impactfn
    ON CONFLICT ON CONSTRAINT updates_c01 DO UPDATE SET scoring_status=0;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="investment_aggregates_update_impacts" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
-- Clear existing
DELETE FROM aggregate_impacts WHERE aggregate_level=3 AND entity_id=this_entity_id;
-- Insert totals row
INSERT INTO aggregate_impacts (aggregate_level, entity_id, tags_hash_md5, risk_factor_id, scenario_id, yr, impact_abs)
SELECT 3 AS level, this_entity_id, tags_hash_md5, risk_factor_id, scenario_id, yr, SUM(impact_abs)
FROM aggregate_impacts
WHERE aggregate_level=2 AND entity_id IN (SELECT DISTINCT assets.id FROM assets WHERE assets.investment_id=this_entity_id AND assets.is_active = 1)
GROUP BY tags_hash_md5, risk_factor_id, scenario_id, yr ORDER BY tags_hash_md5, risk_factor_id, scenario_id, yr;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="investment_aggregates_update_totals" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
-- Clear existing
DELETE FROM aggregate_totals WHERE aggregate_level=3 AND entity_id=this_entity_id;
-- Insert totals row
INSERT INTO aggregate_totals (aggregate_level, entity_id, tags_hash_md5, qty_children, qty_children_done,
							  value_abs, qty_assets, qty_assets_complete_hazards, qty_assets_complete_risks)
SELECT 3 AS level, this_entity_id, tags_hash_md5,
		investment_qty_assets(this_entity_id, tags_hash_md5),
		investment_qty_assets_aggregated(this_entity_id, tags_hash_md5),
		SUM(value_abs), SUM(qty_assets), SUM(qty_assets_complete_hazards), SUM(qty_assets_complete_risks)
FROM aggregate_totals
WHERE aggregate_level=2 AND entity_id IN (SELECT DISTINCT assets.id FROM assets WHERE assets.investment_id=this_entity_id AND assets.is_active = 1)
GROUP BY tags_hash_md5;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="investment_flag_to_eval" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT asset_flag_to_eval(assets.id) FROM assets WHERE investment_id=this_entity_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="investment_impact_to_fmv_by_scenario_decade_riskfactor" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT SUM(asset_impact_to_fmv_by_scenario_decade_riskfactor(assets.id, this_scen_id, this_decade, this_risk_factor_id))
FROM assets
WHERE assets.investment_id=this_investment_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="investment_qty_assets" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	total integer := 0;
BEGIN
	IF this_hash=MD5('') THEN -- No tags
		SELECT COUNT(*)::integer INTO total FROM assets WHERE investment_id=this_entity_id AND assets.is_active = 1;
	ELSE -- Tags
		SELECT COUNT(*)::integer INTO total
		FROM (assets INNER JOIN aggregate_totals ON assets.id=aggregate_totals.entity_id AND assets.is_active = 1)
		WHERE investment_id=this_entity_id AND tags_hash_md5=this_hash AND aggregate_level=2;
	END IF;
	RETURN total;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="investment_qty_assets_aggregated" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT COUNT(*)::integer
	FROM (assets INNER JOIN aggregate_totals ON assets.id=aggregate_totals.entity_id)
	WHERE aggregate_totals.aggregate_level=2 AND tags_hash_md5=this_hash
		AND assets.investment_id=this_entity_id
		AND assets.is_active = 1
		AND aggregate_totals.qty_assets_complete_hazards=1
		AND aggregate_totals.qty_assets_complete_risks=1;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="kill_all_connections" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
BEGIN
                EXECUTE 'SELECT pg_terminate_backend(pg_stat_activity.pid) FROM pg_stat_activity WHERE pg_stat_activity.datname = current_database() AND pid <> pg_backend_pid()';
                RETURN 'ok';
        END
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="list_subscriptions" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
BEGIN
                    RETURN QUERY SELECT * from pg_subscription;
                END
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_aggregates_update" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_asset_id integer;
BEGIN
	SELECT asset_id INTO this_asset_id FROM locations WHERE id=this_loc_id; -- Get asset_id
	PERFORM asset_aggregates_update(this_asset_id); -- Update totals/completeness
	RETURN;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_flag_complete_if_scoring_done" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	rec RECORD;
BEGIN
	SELECT INTO rec * FROM locations WHERE id=this_loc_id;
	IF rec.proc_flag_loc_assign_regional=1
		AND rec.proc_flag_loc_assign_segmented=1
		AND rec.proc_flag_loc_assign_gridded=1
		AND rec.proc_flag_loc_assign_point=1 THEN
			UPDATE locations SET proc_flag_loc_eval_risks=1
				WHERE id=this_loc_id;
			UPDATE updates SET scoring_status=1
				WHERE entity_id=this_loc_id AND entity_type=1;
			UPDATE updates SET scoring_status=1
				WHERE entity_id=rec.asset_id AND entity_type=2
				AND rec.asset_id NOT IN (SELECT locations.asset_id
					FROM locations WHERE proc_flag_loc_eval_risks!=1);
	END IF;
    RETURN;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_flag_to_eval" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
UPDATE locations
SET proc_flag_loc_eval_risks=0,
proc_flag_loc_assign_gridded=0,
proc_flag_loc_assign_segmented=0,
proc_flag_loc_assign_point=0,
proc_flag_loc_assign_regional=0
WHERE id=this_loc_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_gridsquares_assign" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	this_loc_lat double precision;
	this_loc_lng double precision;
	total integer;
	gridname text;
	squarename text;
	squareid integer;
	hazmet_rec RECORD;
	scen_rec RECORD;
	this_decade integer;
BEGIN
	SELECT INTO total COUNT(*) FROM loc_grid_squares WHERE loc_id=this_loc_id;
	IF total=0 THEN
		SELECT INTO this_loc_lat locations.lat FROM locations WHERE locations.id=this_loc_id;
		SELECT INTO this_loc_lng locations.lng FROM locations WHERE locations.id=this_loc_id;
		squarename := (SELECT grid_square_name_make(this_grid_name_etl, this_loc_lat, this_loc_lng));
		-- RAISE NOTICE 'squarename: %', squarename;
		-- Ensure climate data exists for every gridded hazard metric at this grid square
		SELECT INTO squareid grid_squares.id FROM grid_squares WHERE grid_squares.name_etl=squarename;
		-- RAISE NOTICE 'squareid: %', squareid;
		FOR hazmet_rec IN (SELECT * FROM hazard_metrics WHERE class=1 AND do_not_approximate=false) LOOP
			-- RAISE NOTICE 'Hazmet: %', hazmet_rec.name_etl;
			FOR scen_rec IN (SELECT * FROM scenarios) LOOP -- Each scenario
				SELECT INTO total COUNT(*) FROM decadal_states
					WHERE grid_square_id=squareid AND hazard_metric_id=hazmet_rec.id AND scenario_id=scen_rec.id AND decade=0;
				IF total=0 THEN
					RAISE NOTICE 'approximate';
					PERFORM decadal_states_approximate(squareid,hazmet_rec.id,scen_rec.id,0); -- Historical
				END IF;
				SELECT INTO total COUNT(*) FROM decadal_states
					WHERE grid_square_id=squareid AND hazard_metric_id=hazmet_rec.id AND scenario_id=scen_rec.id AND decade>0;
				IF total<9 THEN
					FOR this_decade IN 2010..2090 BY 10 LOOP -- Each decade
						PERFORM decadal_states_approximate(squareid,hazmet_rec.id,scen_rec.id,this_decade); -- This decade
					END LOOP;
				END IF;
			END LOOP;
		END LOOP;
		-- Do grid square assignment
		INSERT INTO loc_grid_squares (loc_id, grid_square_id)
			SELECT this_loc_id, grid_squares.id
			FROM (grid_squares INNER JOIN grids ON grid_squares.grid_id=grids.id)
			WHERE grid_squares.name_etl=squarename;
	END IF;
    RETURN;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_gridsquares_unassign" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
DELETE FROM loc_grid_squares WHERE loc_grid_squares.id IN
(SELECT loc_grid_squares.id FROM ((loc_grid_squares
	INNER JOIN grid_squares ON loc_grid_squares.grid_square_id=grid_squares.id)
	INNER JOIN grids ON grid_squares.grid_id=grids.id)
WHERE loc_grid_squares.loc_id=this_loc_id AND grids.name_etl=this_grid_name_etl);
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_queue_for_eval" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
-- Create update entry for location
	DELETE FROM updates WHERE entity_type=1 AND action=101 AND entity_id=this_loc_id;
	INSERT INTO updates (entity_type, entity_id, action, scoring_status) -- Else insert
	SELECT 1, this_loc_id, 101, 0 FROM locations
	WHERE locations.id=this_loc_id
		AND NOT EXISTS (SELECT * FROM updates
						WHERE entity_type=1 AND action=101 AND entity_id=(SELECT DISTINCT id FROM locations WHERE id=this_loc_id));
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_regions_assign" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	total integer;
BEGIN
	SELECT INTO total COUNT(*) FROM loc_regions WHERE loc_id=this_loc_id;
	IF total=0 THEN
		INSERT INTO loc_regions (loc_id, region_id)
			SELECT DISTINCT this_loc_id, regions.id
			FROM ((regions INNER JOIN region_areas ON regions.id=region_areas.region_id)
				 INNER JOIN locations ON region_areas.name_admin0=locations.admin_area_level0)
			WHERE regions.reg_system=this_reg_system
				AND locations.id=this_loc_id;
	END IF;
    RETURN;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_regions_unassign" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
DELETE FROM loc_regions
WHERE loc_id=this_loc_id AND region_id IN
(SELECT regions.id FROM regions WHERE regions.reg_system=this_reg_system);
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_risks_clear" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT loc_risks_clear_class(this_loc_id,1); -- gridded
SELECT loc_risks_clear_class(this_loc_id,2); -- point
SELECT loc_risks_clear_class(this_loc_id,3); -- regional
SELECT loc_risks_clear_class(this_loc_id,4); -- segmented
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_risks_clear_class" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
DELETE FROM risks WHERE risks.location_id=this_loc_id AND risks.impact_pathway_id IN (SELECT impact_pathways.id
	FROM ((impact_pathways INNER JOIN impact_functions ON impact_pathways.impact_function_id=impact_functions.id)
		 INNER JOIN hazard_metrics ON impact_functions.hazard_metric_id=hazard_metrics.id)
	WHERE hazard_metrics.class=this_hazclass);
DELETE FROM risks WHERE risks.id IN (SELECT risks.id
	FROM (((risks
			LEFT JOIN locations ON risks.location_id=locations.id)
			LEFT JOIN impact_pathways ON risks.impact_pathway_id=impact_pathways.id)
			LEFT JOIN impact_functions ON impact_pathways.impact_function_id=impact_functions.id)
	WHERE  risks.location_id=this_loc_id AND impact_functions.id IS NULL);
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_risks_eval" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
UPDATE locations
	SET proc_flag_loc_eval_risks=-1 -- Flag scoring in progress on this location.
	WHERE id=this_loc_id;
SELECT loc_risks_eval_gridded(this_loc_id); -- Evaluate risks for this location.
SELECT loc_risks_eval_point(this_loc_id);
SELECT loc_risks_eval_regional(this_loc_id);
SELECT loc_risks_eval_segmented(this_loc_id);
SELECT loc_flag_complete_if_scoring_done(this_loc_id); -- Mark complete if possible
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_risks_eval_gridded" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
-- Mark scoring in progress
UPDATE locations SET proc_flag_loc_assign_gridded=-1 WHERE locations.id=this_loc_id;
SELECT loc_risks_clear_class(this_loc_id, 1); -- Clear risks
SELECT loc_gridsquares_unassign(this_loc_id, 'nexgddp'); -- Unassign grid squares
SELECT loc_gridsquares_unassign(this_loc_id, 'loca');
-- Assign location to grid squares
-- SELECT loc_gridsquares_assign(this_loc_id, 'loca');
SELECT loc_gridsquares_assign(this_loc_id, 'nexgddp');
SELECT loc_risks_eval_gridded_assign(this_loc_id); -- Insert risks
UPDATE locations SET proc_flag_loc_assign_gridded=1 WHERE locations.id=this_loc_id; -- Mark complete
SELECT loc_flag_complete_if_scoring_done(this_loc_id);
-- SELECT loc_aggregates_update(this_loc_id); -- Cache aggregates commented by SD 05/14/2021
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_risks_eval_gridded_assign" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
INSERT INTO risks (location_id, scenario_id, impact_pathway_id, yr, portion_at_risk)
SELECT DISTINCT ON(locid, scenid, pathwayid, decadal_states.decade) locations.id AS locid,
	decadal_states.scenario_id AS scenid,
	impact_pathways.id AS pathwayid,
	decadal_states.decade,
	(risk_eval(CAST(decadal_states.hazard_metric_mean AS numeric),impact_pathways.list_xvalues,impact_pathways.list_yvalues)
	- risk_eval(CAST(historical_states.hazard_metric_mean AS numeric),impact_pathways.list_xvalues,impact_pathways.list_yvalues))
	/ (SELECT COUNT(*) FROM locations WHERE asset_id=assets.id)
	AS risk
FROM ((((((((((decadal_states
	INNER JOIN grid_squares ON decadal_states.grid_square_id=grid_squares.id)
	INNER JOIN grids ON grid_squares.grid_id=grids.id)
	INNER JOIN loc_grid_squares ON grid_squares.id=loc_grid_squares.grid_square_id)
	INNER JOIN locations ON loc_grid_squares.loc_id=locations.id)
	INNER JOIN assets ON locations.asset_id=assets.id)
	INNER JOIN assets_impact_functions ON assets.id=assets_impact_functions.asset_id)
	INNER JOIN impact_functions ON assets_impact_functions.impact_function_id=impact_functions.id)
	INNER JOIN hazard_metrics ON impact_functions.hazard_metric_id=hazard_metrics.id)
	INNER JOIN impact_pathways ON impact_pathways.impact_function_id=impact_functions.id)
	INNER JOIN decadal_states AS historical_states ON historical_states.grid_square_id=grid_squares.id)
WHERE locations.id=this_loc_id
	AND decadal_states.decade <> 0
	AND historical_states.decade=0
	AND historical_states.decadal_state_type=1
	AND hazard_metrics.id=decadal_states.hazard_metric_id
	AND decadal_states.decadal_state_type=1
	AND historical_states.hazard_metric_id=hazard_metrics.id
	AND historical_states.scenario_id=decadal_states.scenario_id
ORDER BY locid, scenid, decade;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_risks_eval_if_needed" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	rec RECORD;
BEGIN
	SELECT INTO rec * FROM locations WHERE id=this_loc_id;
	IF rec.proc_flag_loc_assign_point=0 THEN
		PERFORM loc_risks_eval_point(this_loc_id);
	END IF;
	IF rec.proc_flag_loc_assign_gridded=0 THEN
		PERFORM loc_risks_eval_gridded(this_loc_id);
	END IF;
	IF rec.proc_flag_loc_assign_segmented=0 THEN
		PERFORM loc_risks_eval_segmented(this_loc_id);
	END IF;
	IF rec.proc_flag_loc_assign_regional=0 THEN
		PERFORM loc_risks_eval_regional(this_loc_id);
	END IF;
	PERFORM loc_flag_complete_if_scoring_done(this_loc_id);
    RETURN;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_risks_eval_point" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	c_hazmet integer;
	c_hazmets_missing integer;
	f integer;
	asset_cache_state integer;
BEGIN
	-- Check whether this loc has point hazards via impact fns
	SELECT INTO c_hazmet COUNT(DISTINCT hazard_metrics.id) FROM (((locations
		INNER JOIN assets_impact_functions ON locations.asset_id=assets_impact_functions.asset_id)
		INNER JOIN impact_functions ON assets_impact_functions.impact_function_id=impact_functions.id)
		INNER JOIN hazard_metrics ON impact_functions.hazard_metric_id=hazard_metrics.id)
		WHERE locations.id=this_loc_id AND hazard_metrics.class=2;
	IF (c_hazmet=0) THEN
		f := 1;
	ELSE
		f := -1;
	END IF;
	IF f=-1 THEN
		-- PERFORM loc_risks_clear_class(this_loc_id, 2);
		SELECT INTO c_hazmets_missing COUNT(hazard_metrics.id) FROM hazard_metrics
		WHERE hazard_metrics.class=2
			AND hazard_metrics.id IN ( -- Hazmets assigned to this asset
					SELECT DISTINCT hazard_metrics.id
					FROM ((((hazard_metrics
					INNER JOIN impact_functions ON hazard_metrics.id=impact_functions.hazard_metric_id)
					INNER JOIN assets_impact_functions ON impact_functions.id=assets_impact_functions.impact_function_id)
					INNER JOIN assets ON assets_impact_functions.asset_id=assets.id)
					INNER JOIN locations ON assets.id=locations.asset_id)
					WHERE locations.id=this_loc_id AND hazard_metrics.class=2)
			AND hazard_metrics.id NOT IN ( -- Hazmets with complete set of decstates
					SELECT hazard_metric_id FROM decadal_states
					WHERE decadal_states.point_loc_id=this_loc_id
					GROUP BY decadal_states.hazard_metric_id
					HAVING COUNT(*)>=(SELECT COUNT(*) FROM scenarios WHERE id IN (1,2)) * 10); -- Updates by YW 11/09/2021 pre-RCP 2.6/6.0
		IF c_hazmets_missing=0 THEN -- If all decstates are present
			PERFORM loc_risks_eval_point_assign(this_loc_id);
			f := 1;
		-- ELSE
			-- DELETE FROM decadal_states
				-- WHERE decadal_state_type=2 AND point_loc_id=this_loc_id;
			-- SELECT INTO asset_cache_state COUNT(*) FROM aggregate_totals WHERE aggregate_level=2 AND tags_hash_md5=MD5('') AND entity_id=(SELECT DISTINCT asset_id FROM locations WHERE id=this_loc_id) AND qty_children_done=qty_children;
			-- IF (asset_cache_state>0) THEN
			-- 	PERFORM asset_aggregates_update_totals(asset_id) FROM locations WHERE id=this_loc_id; -- Remove from cache
			-- END IF;
		END IF;
	END IF;
	-- Set progress flag
	UPDATE locations SET proc_flag_loc_assign_point=f WHERE locations.id=this_loc_id;
	-- Wait for external service to call loc_risks_eval_point_assign
    RETURN;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_risks_eval_point_assign" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT loc_risks_clear_class(this_loc_id, 2);
INSERT INTO risks (location_id, scenario_id, impact_pathway_id, yr, portion_at_risk)
SELECT DISTINCT locations.id AS locid,
	decadal_states.scenario_id AS scenid,
	impact_pathways.id AS pathwayid,
	decadal_states.decade,
	(risk_eval(CAST(decadal_states.hazard_metric_mean AS numeric), impact_pathways.list_xvalues, impact_pathways.list_yvalues)
	- risk_eval(CAST(historical_states.hazard_metric_mean AS numeric), impact_pathways.list_xvalues, impact_pathways.list_yvalues))
	/ (SELECT COUNT(*) FROM locations WHERE asset_id=assets.id)
	AS risk
FROM (((((((decadal_states
	INNER JOIN locations ON decadal_states.point_loc_id=locations.id)
	INNER JOIN assets ON locations.asset_id=assets.id)
	INNER JOIN assets_impact_functions ON assets.id=assets_impact_functions.asset_id)
	INNER JOIN impact_functions ON assets_impact_functions.impact_function_id=impact_functions.id)
	INNER JOIN hazard_metrics ON impact_functions.hazard_metric_id=hazard_metrics.id)
	INNER JOIN impact_pathways ON impact_pathways.impact_function_id=impact_functions.id)
	INNER JOIN decadal_states AS historical_states ON historical_states.point_loc_id=this_loc_id)
WHERE locations.id=this_loc_id
	AND decadal_states.decade <> 0
	AND decadal_states.decadal_state_type=2
	AND hazard_metrics.id=decadal_states.hazard_metric_id
	AND historical_states.scenario_id=decadal_states.scenario_id
	AND historical_states.decade=0
	AND historical_states.decadal_state_type=2
	AND historical_states.hazard_metric_id=hazard_metrics.id
ORDER BY locid, scenid, pathwayid, decade;
UPDATE locations SET proc_flag_loc_assign_point=1 WHERE locations.id=this_loc_id; -- Mark complete
SELECT loc_flag_complete_if_scoring_done(this_loc_id);
-- SELECT loc_aggregates_update(this_loc_id); -- Cache aggregates commented by SD 05/14/2021
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_risks_eval_regional" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
-- Mark in progress
UPDATE locations SET proc_flag_loc_assign_regional=-1 WHERE locations.id=this_loc_id;
-- Clear risks and assign grid squares
SELECT loc_risks_clear_class(this_loc_id, 3);
SELECT loc_regions_unassign(this_loc_id, 1);
SELECT loc_regions_assign(this_loc_id, 1);
-- Insert risks and mark complete
SELECT loc_risks_eval_regional_assign(this_loc_id);
SELECT loc_risks_eval_regional_assign_carbon(this_loc_id);
UPDATE locations SET proc_flag_loc_assign_regional=1 WHERE locations.id=this_loc_id;
SELECT loc_flag_complete_if_scoring_done(this_loc_id);
-- SELECT loc_aggregates_update(this_loc_id); -- Cache aggregates commented by SD 05/14/2021
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_risks_eval_regional_assign" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
INSERT INTO risks (location_id, scenario_id, impact_pathway_id, yr, portion_at_risk)
SELECT DISTINCT locations.id AS locid,
	decadal_states.scenario_id AS scenid,
	impact_pathways.id AS pathwayid,
	decadal_states.decade,
	risk_eval(CAST(decadal_states.hazard_metric_mean AS numeric), impact_pathways.list_xvalues, impact_pathways.list_yvalues)
	/ (SELECT COUNT(*) FROM locations WHERE asset_id=assets.id)
FROM (((((((decadal_states
	INNER JOIN loc_regions ON decadal_states.region_id=loc_regions.region_id)
	INNER JOIN locations ON loc_regions.loc_id=locations.id)
	INNER JOIN assets ON locations.asset_id=assets.id)
	INNER JOIN assets_impact_functions ON assets.id=assets_impact_functions.asset_id)
	INNER JOIN impact_functions ON assets_impact_functions.impact_function_id=impact_functions.id)
	INNER JOIN hazard_metrics ON impact_functions.hazard_metric_id=hazard_metrics.id)
	INNER JOIN impact_pathways ON impact_pathways.impact_function_id=impact_functions.id)
WHERE locations.id=this_loc_id
	AND decadal_states.decade <> 0
	AND hazard_metrics.id=decadal_states.hazard_metric_id
	AND decadal_states.decadal_state_type=3
	AND impact_functions.scoring_method=1
ORDER BY locid, scenid, decade;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_risks_eval_regional_assign_carbon" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
INSERT INTO risks (location_id, scenario_id, impact_pathway_id, yr, portion_at_risk)
SELECT DISTINCT locations.id AS locid,
	decadal_states.scenario_id AS scenid,
	impact_pathways.id AS pathwayid,
	decadal_states.decade,
	risk_eval_carbonprice(CAST(decadal_states.hazard_metric_mean AS numeric), impact_pathways.list_xvalues, impact_pathways.list_yvalues, CAST(assets.emissions AS numeric), CAST(assets.asset_value AS numeric))
	/ (SELECT COUNT(*) FROM locations WHERE asset_id=assets.id)
FROM (((((((decadal_states
	INNER JOIN loc_regions ON decadal_states.region_id=loc_regions.region_id)
	INNER JOIN locations ON loc_regions.loc_id=locations.id)
	INNER JOIN assets ON locations.asset_id=assets.id)
	INNER JOIN assets_impact_functions ON assets.id=assets_impact_functions.asset_id)
	INNER JOIN impact_functions ON assets_impact_functions.impact_function_id=impact_functions.id)
	INNER JOIN hazard_metrics ON impact_functions.hazard_metric_id=hazard_metrics.id)
	INNER JOIN impact_pathways ON impact_pathways.impact_function_id=impact_functions.id)
WHERE locations.id=this_loc_id
	AND decadal_states.decade <> 0
	AND hazard_metrics.id=decadal_states.hazard_metric_id
	AND decadal_states.decadal_state_type=3
	AND impact_functions.scoring_method=2
ORDER BY locid, scenid, decade;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_risks_eval_segmented" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
-- Mark in progress
UPDATE locations SET proc_flag_loc_assign_segmented=-1 WHERE locations.id=this_loc_id;
-- Mark complete
UPDATE locations SET proc_flag_loc_assign_segmented=1 WHERE locations.id=this_loc_id;
SELECT loc_flag_complete_if_scoring_done(this_loc_id);
-- SELECT loc_aggregates_update(this_loc_id); -- Cache aggregates commented by SD 05/14/2021
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="loc_risks_rpt" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT portion_at_risk
FROM (((((risks
	INNER JOIN locations ON risks.location_id=locations.id)
	INNER JOIN impact_pathways ON risks.impact_pathway_id=impact_pathways.id)
	INNER JOIN impact_functions ON impact_pathways.impact_function_id=impact_functions.id)
	INNER JOIN hazard_metrics ON impact_functions.hazard_metric_id=hazard_metrics.id)
	INNER JOIN scenarios ON risks.scenario_id=scenarios.id)
WHERE risks.location_id=this_loc_id
	AND yr=this_decade
	AND scenario_id=this_scen_id
	AND impact_functions.risk_factor_id=this_risk_factor_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="locs_risks_eval_if_needed" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
rec RECORD;
BEGIN
	FOR rec IN (SELECT id FROM locations) LOOP -- Process each location for scoring.
		PERFORM loc_risks_eval_if_needed(rec.id); -- Evaluate risks for this location.
	END LOOP;	
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="locs_risks_eval_if_needed_range" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
rec RECORD;
BEGIN
	FOR rec IN (SELECT id FROM locations WHERE id>=first AND id<=last) LOOP -- Process each location for scoring.
		PERFORM loc_risks_eval_if_needed(rec.id); -- Evaluate risks for this location.
	END LOOP;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="locs_risks_eval_range" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
rec RECORD;
BEGIN
	FOR rec IN (SELECT id FROM locations WHERE id>=first AND id<=last) LOOP -- Process each location for scoring.
		PERFORM loc_risks_eval(rec.id); -- Evaluate risks for this location.
	END LOOP;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="locs_update_proc" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[This trigger function for the locations table will delete point decadal states if the lat, lon, or elevation of a location has changed. This is so, upon some other process (UI) rescoring that location, new point hazard data will be brought in.]]></comment>
         <definition language="PLPGSQL"><![CDATA[
BEGIN
	IF NEW.lng!=OLD.lng OR NEW.lat!=OLD.lat
		OR NEW.elevation_m_rel2lmsl!=OLD.elevation_m_rel2lmsl
		THEN PERFORM decadal_states_clear_by_location_point_hazards(NEW.id);
	END IF;
	RETURN null;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="max" returnType="citext" securityType="INVOKER" type="AGGREGATE">
         <comment/>
         <definition language="INTERNAL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="min" returnType="citext" securityType="INVOKER" type="AGGREGATE">
         <comment/>
         <definition language="INTERNAL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="modulus" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
  result numeric;
BEGIN
  divisor := ABS(divisor);
  result  := MOD(dividend, divisor);
  IF result < 0 THEN
    result := result + divisor;
  END IF;
  RETURN result;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="notify_trigger" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
  rec RECORD;
  payload TEXT;
  notification_channel TEXT := TG_OP || '-' || TG_TABLE_NAME;
  column_name TEXT;
  column_value TEXT;
  payload_items JSONB;
BEGIN
  -- Set record row depending on operation
  CASE TG_OP
  WHEN 'INSERT', 'UPDATE' THEN
     rec := NEW;
  WHEN 'DELETE' THEN
     rec := OLD;
  ELSE
     RAISE EXCEPTION 'Unknown TG_OP trigger operation: "%".', TG_OP;
  END CASE;
  
  -- Get required fields
  FOREACH column_name IN ARRAY TG_ARGV LOOP
    EXECUTE format('SELECT $1.%I::TEXT', column_name)
    INTO column_value
    USING rec;
    payload_items := coalesce(payload_items,'{}')::jsonb || json_build_object(column_name,column_value)::jsonb;
  END LOOP;

  -- Build the payload
  payload := json_build_object(
    'timestamp',CURRENT_TIMESTAMP,
    'operation',TG_OP,
    'schema',TG_TABLE_SCHEMA,
    'table',TG_TABLE_NAME,
    'data',payload_items
  );

  -- Notify the channel
  PERFORM pg_notify(notification_channel, payload);
  
  RETURN rec;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pg_kill_connection" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
select pg_terminate_backend($1);
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pg_notify_array" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
    array_length INT := cardinality(input_array);
    t timestamptz := clock_timestamp();
BEGIN
    -- pg_notify accepts (text, text), so casting Assets ID here.
    PERFORM pg_notify(
        channel_name,
        json_build_object(
            'data',
            json_build_object(
                data_key_name,
                -- grab input_array from array using a generated sequence based upon slice length value
                array_to_string(input_array[(g.subslice * slice_length) - (slice_length - 1) : (g.subslice * slice_length)], ',')
            )
        )::TEXT
    ) FROM 
    generate_series(1,1 + ROUND(array_length / slice_length)::int) AS g(subslice);
    RAISE NOTICE 'pg_notify_array execution duration: %', clock_timestamp() - t; 
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="refresh_subscription" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
                     persist_dblink_extension boolean;
                BEGIN
                    persist_dblink_extension := create_dblink_extension();
                    PERFORM dblink_connect(format('dbname=%s', db_name));
                    PERFORM dblink_exec(format('ALTER SUBSCRIPTION %s REFRESH PUBLICATION',subscription_name));
                    PERFORM dblink_disconnect();

                    IF persist_dblink_extension = FALSE
                    THEN
                        DROP EXTENSION IF EXISTS dblink;
                    END IF;
                    RETURN 'ok';
                END
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="regexp_match" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="regexp_matches" returnType="SETOF ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="regexp_replace" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="regexp_split_to_array" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="regexp_split_to_table" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="replace" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="risk_aggregates_proc_n" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
    qty_remaining integer := 0;
    qty_in_progress integer := 0;
    assets_completed TEXT[];
    t timestamptz := clock_timestamp();
BEGIN
    -- Clear any aggregation request updates related to disabled assets
    DELETE FROM updates WHERE id IN -- Locations of disabled assets
        (SELECT updates.id
         FROM ((updates INNER JOIN locations ON updates.entity_id=locations.id)
              INNER JOIN assets ON locations.asset_id=assets.id)
         WHERE updates.entity_type=1 AND (updates.action=100 OR updates.action=101) AND assets.is_active=0);


    -- Set any aggregation request updates related to unlinked assets as unnecessary
    UPDATE updates SET scoring_status = 1, aggregation_status = 1 WHERE entity_type = 1 AND entity_id IN 
    (SELECT distinct updates.entity_id 
        FROM updates INNER JOIN 
        locations ON updates.entity_id = locations.id INNER JOIN assets ON locations.asset_id = assets.id LEFT JOIN 
        folders_investments ON assets.investment_id = folders_investments.investment_id LEFT JOIN 
        folders ON folders_investments.folder_id = folders.id LEFT JOIN groups ON folders.group_id = groups.id 
        WHERE updates.entity_type = 1 AND assets.is_active = 1 AND groups.customer_id IS NULL
    );

    -- Set the flag as processed for any aggregation request for a Location where a subsequent action (i.e. non-aggregated rows for both 100 and 101 actions) is already present
    UPDATE updates SET aggregation_status = 1 WHERE 
        scoring_status = 1 AND action = 100 AND entity_type = 1 AND aggregation_status = 0 AND 
        entity_id IN (
            SELECT entity_id FROM updates WHERE 
            scoring_status = 1 AND aggregation_status = 0 AND action = 101 AND entity_type = 1
            );

    -- Any aggregation already in progress?
    SELECT INTO qty_in_progress COUNT(id) FROM updates WHERE aggregation_status=-1 AND entity_type=1 AND (action=100 OR action=101);
    IF qty_in_progress>0 THEN qty_remaining=-1; -- Something is still in progress
    ELSE -- Mark batch of locations and handle them, if they have already been scored
        IF earliest_or_latest='latest' THEN
            UPDATE updates SET aggregation_status=-1 WHERE id IN
                (SELECT id FROM updates WHERE aggregation_status=0 AND scoring_status=1 AND entity_type=1 AND (action=100 OR action=101) ORDER BY id DESC LIMIT qty_to_process);
        ELSE
            UPDATE updates SET aggregation_status=-1 WHERE id IN
                (SELECT id FROM updates WHERE aggregation_status=0 AND scoring_status=1 AND entity_type=1 AND (action=100 OR action=101) ORDER BY id ASC LIMIT qty_to_process);
        END IF;
        PERFORM loc_aggregates_update(entity_id) FROM updates WHERE aggregation_status=-1 AND scoring_status=1 AND entity_type=1 AND (action=100 OR action=101); -- Locations
        /* 
            pg_notify_array wraps around pg_notify, which has a character limit of 8000.
            If we assume Asset IDs will hit 7 characters, plus a comma, we are limited to 1000 per NOTIFY,
            which we list as 900 here to be safe.
        */
        assets_completed := (SELECT ARRAY_AGG(DISTINCT assets.id::TEXT) FROM assets 
                INNER JOIN locations ON locations.asset_id = assets.id 
                INNER JOIN updates ON locations.id = updates.entity_id 
                WHERE 
                    updates.aggregation_status=-1 AND 
                    updates.scoring_status=1 AND 
                    updates.entity_type=1 AND 
                    (updates.action=100 OR updates.action=101));
        PERFORM pg_notify_array(
            assets_completed, 
            900, 
            'aggregated-assets',
            'id'
        );
        UPDATE updates SET aggregation_status=1 WHERE aggregation_status=-1 AND scoring_status=1 AND entity_type=1 AND (action=100 OR action=101); -- Mark batch as done
        SELECT INTO qty_remaining COUNT(DISTINCT id) FROM updates WHERE aggregation_status!=1 AND scoring_status=1 AND entity_type=1 AND (action=100 OR action=101); -- Get qty_remaining
    END IF;
    RAISE NOTICE 'risk_aggregates_proc_n execution duration: %', clock_timestamp() - t;
    RETURN qty_remaining; -- Return qty_remaining (or -1 for in progress)
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="risk_eval" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	not_at_risk_percent numeric;
	at_risk numeric := 0;
BEGIN
	not_at_risk_percent := breakpoints_interpolate(x, xlist, ylist);
	at_risk := 1 - not_at_risk_percent / 100;	
	RETURN ROUND(at_risk, 10);
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="risk_eval_carbonprice" returnType="numeric" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	at_risk numeric := 0;
	price numeric;
BEGIN
	price := breakpoints_interpolate(x, xlist, ylist);
	IF val!=0 THEN
		at_risk := (price * emissions)/val;
	ELSE
		at_risk := 0;
	END IF;
	RETURN ROUND(at_risk, 10);
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="score_asset" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT asset_flag_to_eval(id) FROM assets WHERE assets.id=this_asset_id AND is_active=1;
SELECT score_location(locations.id) FROM (locations INNER JOIN assets ON locations.asset_id=assets.id) WHERE assets.id=this_asset_id AND assets.is_active=1;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="score_customer" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT customer_flag_to_eval(this_customer_id);
SELECT score_group(id) FROM groups WHERE customer_id=this_customer_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="score_folder" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT folder_flag_to_eval(this_folder_id);
SELECT score_investment(investment_id) FROM folders_investments WHERE folder_id=this_folder_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="score_group" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT group_flag_to_eval(this_group_id);
SELECT score_folder(id) FROM folders WHERE group_id=this_group_id;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="score_investment" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
SELECT investment_flag_to_eval(this_investment_id);
SELECT score_asset(id) FROM assets WHERE investment_id=this_investment_id AND assets.is_active = 1;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="score_location" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"><![CDATA[
UPDATE aggregate_totals SET qty_assets_complete_risks=0 WHERE aggregate_level=2 AND entity_id=(SELECT asset_id FROM locations WHERE id=this_loc_id);
SELECT loc_flag_to_eval(this_loc_id); -- Flag this location to be completely scored.
SELECT loc_risks_eval(this_loc_id); -- Evaluate risks for this location.
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_pgaudit_session_logging" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
                persist_dblink_extension boolean;
                allowed_events TEXT [];
                input_valid boolean;
                pgaudit_ver_check boolean;
        BEGIN
            --misc_set is only available in pgAudit >= 1.4
            SELECT version >= '1.4' FROM pg_available_extension_versions WHERE name = 'pgaudit' INTO pgaudit_ver_check;
            IF pgaudit_ver_check is true
            THEN
                allowed_events := '{function,role,ddl,misc,misc_set,none}';
            ELSE
                allowed_events := '{function,role,ddl,misc,none}';
            END IF;
             --lower case the input for case insensitive comparison.
            SELECT array_agg(x.events) INTO events FROM (SELECT btrim(lower(unnest(events)))::TEXT AS events) AS x;
            SELECT events  <@ allowed_events INTO input_valid;
            IF not input_valid
            THEN
                RAISE EXCEPTION 'Invalid options provided: %, Allowed events: %.', events,allowed_events;
            END IF;
            persist_dblink_extension := create_dblink_extension();
            PERFORM dblink_connect(format('dbname=postgres'));
            PERFORM dblink_exec(format('ALTER SYSTEM SET pgaudit.log TO %s;',array_to_string(events, ',')));
            PERFORM dblink_disconnect();
            PERFORM pg_reload_conf();
            IF persist_dblink_extension = FALSE
            THEN
                DROP EXTENSION IF EXISTS dblink;
            END IF;
            RETURN 'ok';
        END
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="setval_max" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
-- Sets all the sequences in the schema "schema_name" to the max(id) of every table (or a specific table, if name is supplied)
-- Examples:
-- 	SELECT setval_max('public');
-- 	SELECT setval_max('public','mytable');
-- 	SELECT setval_max('public',null,true);
-- 	SELECT setval_max('public','mytable',true);

DECLARE
	row_data RECORD;
	sql_code TEXT;

BEGIN
	IF ((SELECT COUNT(*) FROM pg_namespace WHERE nspname = schema_name) = 0) THEN
		RAISE EXCEPTION 'The schema "%" does not exist', schema_name;
	END IF;

	FOR sql_code IN
		SELECT 'SELECT SETVAL(' ||quote_literal(N.nspname || '.' || S.relname)|| ', MAX(' ||quote_ident(C.attname)|| ') ) FROM ' || quote_ident(N.nspname) || '.' || quote_ident(T.relname)|| ';' AS sql_code
			FROM pg_class AS S
			INNER JOIN pg_depend AS D ON S.oid = D.objid
			INNER JOIN pg_class AS T ON D.refobjid = T.oid
			INNER JOIN pg_attribute AS C ON D.refobjid = C.attrelid AND D.refobjsubid = C.attnum
			INNER JOIN pg_namespace N ON N.oid = S.relnamespace
			WHERE S.relkind = 'S' AND N.nspname = schema_name AND (table_name IS NULL OR T.relname = table_name)
			ORDER BY S.relname
	LOOP
		IF (raise_notice) THEN
			RAISE NOTICE 'sql_code: %', sql_code;
		END IF;
		EXECUTE sql_code;
	END LOOP;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="split_part" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="strpos" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="texticlike" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="INTERNAL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="texticnlike" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="INTERNAL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="texticregexeq" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="INTERNAL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="texticregexne" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="INTERNAL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="translate" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="SQL"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="update_to_postgis_25" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
            postgis_25_ver text;
        BEGIN
                IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname='postgis') THEN
                    RAISE EXCEPTION 'PostGIS is not installed.';
                END IF;
                SELECT
                    version
                INTO
                    postgis_25_ver
                FROM
                    pg_available_extension_versions
                WHERE
                    name='postgis' AND
                    version like '2.5%' AND
                    version NOT LIKE '%next';
                EXECUTE 'ALTER EXTENSION postgis UPDATE to '|| quote_literal(postgis_25_ver);
              --  RETURN 'ok';
        END
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="updates_new_proc" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
	rec RECORD;
	c integer; -- count
	total integer := 0;
	this_asset_id integer;
BEGIN
	IF new.scoring_status=0 AND (new.action=100 OR new.action=101) THEN -- Make a list of locations for scoring.
		DROP TABLE IF EXISTS tlocs;
		CREATE TEMP TABLE tlocs (id integer); -- Temp locations list for scoring
		IF new.entity_type=1 THEN -- 1=location; was 6 with old aggregator service
			-- RAISE NOTICE 'Location updated.';
			INSERT INTO tlocs (SELECT DISTINCT locations.id FROM locations
							  WHERE locations.id=new.entity_id);
		ELSIF new.entity_type=7 THEN
			RAISE NOTICE 'Impact function updated.';
			INSERT INTO tlocs (SELECT DISTINCT locations.id FROM (locations
							  INNER JOIN assets_impact_functions ON locations.asset_id=assets_impact_functions.asset_id)
							  WHERE assets_impact_functions.impact_function_id=new.entity_id);
		END IF;
		SELECT INTO total COUNT(DISTINCT id) FROM tlocs;
	END IF;
	IF total>0 THEN
		-- RAISE NOTICE 'Flag locations for scoring.';
		UPDATE updates SET scoring_status=-1 WHERE id=new.id; -- Mark in progress.

		FOR rec IN (SELECT DISTINCT id FROM tlocs) LOOP -- Process each location for scoring.
			PERFORM score_location(rec.id);
		END LOOP;
		IF new.entity_type=1 THEN -- Count how many are complete.
			SELECT INTO c COUNT(id) FROM locations
	  		WHERE locations.id=new.entity_id
				AND proc_flag_loc_assign_gridded=1
				AND proc_flag_loc_assign_point=1
				AND proc_flag_loc_assign_regional=1
				AND proc_flag_loc_assign_segmented=1;
		ELSIF new.entity_type=7 THEN
			SELECT INTO c COUNT(DISTINCT locations.id) FROM (locations
				INNER JOIN assets_impact_functions
	  			ON locations.asset_id=assets_impact_functions.asset_id)
			WHERE assets_impact_functions.impact_function_id=new.entity_id
				AND proc_flag_loc_assign_gridded=1
				AND proc_flag_loc_assign_point=1
				AND proc_flag_loc_assign_regional=1
				AND proc_flag_loc_assign_segmented=1;
		ELSE
			c := 0;
		END IF;
		IF c=total THEN
			UPDATE updates SET scoring_status=1 WHERE id=new.id; -- Flag complete if they're all done.
		END IF;
	END IF;
	RETURN null;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="updates_proc_n" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
    qty_remaining integer := 0;
    qty_in_progress integer := 0;
BEGIN
    -- Clear any scoring request updates related to disabled assets
    DELETE FROM updates WHERE id IN -- Locations of disabled assets
        (SELECT updates.id
         FROM ((updates INNER JOIN locations ON updates.entity_id=locations.id)
              INNER JOIN assets ON locations.asset_id=assets.id)
         WHERE updates.entity_type=1 AND (updates.action=100 OR updates.action=101) AND assets.is_active=0);
    -- Anything already in progress?
    SELECT INTO qty_in_progress COUNT(id) FROM updates WHERE scoring_status=-1 AND entity_type=1 AND (action=100 OR action=101);
    IF qty_in_progress>0 THEN qty_remaining=-1; -- Something is still in progress
    ELSE -- Mark batch of locations and handle them
        IF earliest_or_latest='latest' THEN
            UPDATE updates SET scoring_status=-1 WHERE id IN
                (SELECT id FROM updates WHERE scoring_status=0 AND entity_type=1 AND (action=100 OR action=101) ORDER BY id DESC LIMIT qty_to_process);
        ELSE
            UPDATE updates SET scoring_status=-1 WHERE id IN
                (SELECT id FROM updates WHERE scoring_status=0 AND entity_type=1 AND (action=100 OR action=101) ORDER BY id ASC LIMIT qty_to_process);
        END IF;
        PERFORM score_location(entity_id) FROM updates WHERE scoring_status=-1 AND entity_type=1 AND (action=100 OR action=101); -- Locations
        UPDATE updates SET scoring_status=1 WHERE scoring_status=-1 AND entity_type=1 AND (action=100 OR action=101); -- Mark batch as done
        SELECT INTO qty_remaining COUNT(DISTINCT id) FROM updates WHERE scoring_status!=1 AND entity_type=1 AND (action=100 OR action=101); -- Get qty_remaining
    END IF;
    RETURN qty_remaining; -- Return qty_remaining (or -1 for in progress)
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="uuid_generate_v1" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="uuid_generate_v1mc" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_generate_v3" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="uuid_generate_v4" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_generate_v5" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_nil" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_ns_dns" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_ns_oid" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_ns_url" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_ns_x500" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
   </routines>
</database>
